"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.describeCluster = exports.ImportClusterProvider = void 0;
const spi_1 = require("../spi");
const generic_cluster_provider_1 = require("./generic-cluster-provider");
const eks = require("aws-cdk-lib/aws-eks");
const sdk = require("@aws-sdk/client-eks");
const utils_1 = require("../resource-providers/utils");
const resource_providers_1 = require("../resource-providers");
const utils_2 = require("../utils");
/**
 * Importing cluster into the blueprint enabling limited blueprinting capabilities such as adding certain addons,
 * teams.
 */
class ImportClusterProvider {
    constructor(props) {
        this.props = props;
    }
    /**
     * Implements contract method to create a cluster, by importing an existing cluster.
     * @param scope
     * @param vpc
     * @param _secretsEncryptionKey
     * @returns
     */
    createCluster(scope, vpc, _secretsEncryptionKey) {
        const props = { ...this.props, vpc };
        if (!props.kubectlLayer) {
            props.kubectlLayer = (0, generic_cluster_provider_1.selectKubectlLayer)(scope, props.version);
        }
        const existingCluster = eks.Cluster.fromClusterAttributes(scope, 'imported-cluster-' + this.props.clusterName, props);
        return new spi_1.ClusterInfo(existingCluster, this.props.version);
    }
    /**
     * Requires iam permission to eks.DescribeCluster at build time. Retrieves the cluster information using DescribeCluster api and
     * creates an import cluster provider.
     * @param clusterName name of the cluster
     * @param region target rego
     * @param kubectlRole iam Role that provides access to the cluster API (kubectl). The CDK custom resource should be able to assume the role
     * which in some cases may require trust policy for the account root principal.
     * @returns the cluster provider with the import cluster configuration
     */
    static async fromClusterLookup(clusterName, region, kubectlRole) {
        const sdkCluster = await describeCluster(clusterName, process.env.CDK_DEFAULT_REGION);
        return this.fromClusterAttributes(sdkCluster, kubectlRole);
    }
    /**
     * Creates a cluster provider for an existing cluster based on the passed result of the describe cluster command.
     * @param sdkCluster
     * @param kubectlRole
     * @returns
     */
    static fromClusterAttributes(sdkCluster, kubectlRole) {
        var _a, _b, _c;
        return new ImportClusterProvider({
            clusterName: sdkCluster.name,
            version: eks.KubernetesVersion.of(sdkCluster.version),
            clusterEndpoint: sdkCluster.endpoint,
            openIdConnectProvider: (0, utils_1.getResource)(context => new resource_providers_1.LookupOpenIdConnectProvider(sdkCluster.identity.oidc.issuer).provide(context)),
            clusterCertificateAuthorityData: (_a = sdkCluster.certificateAuthority) === null || _a === void 0 ? void 0 : _a.data,
            kubectlRoleArn: kubectlRole.roleArn,
            clusterSecurityGroupId: (_b = sdkCluster.resourcesVpcConfig) === null || _b === void 0 ? void 0 : _b.clusterSecurityGroupId,
            securityGroupIds: (_c = sdkCluster.resourcesVpcConfig) === null || _c === void 0 ? void 0 : _c.securityGroupIds
        });
    }
}
exports.ImportClusterProvider = ImportClusterProvider;
/**
 * Wraps API call to get the data on the eks.Cluster.
 * @param clusterName
 * @param region
 * @returns
 */
async function describeCluster(clusterName, region) {
    const client = new sdk.EKSClient({ region });
    const input = {
        name: clusterName
    };
    const command = new sdk.DescribeClusterCommand(input);
    try {
        const response = await client.send(command);
        return response.cluster;
    }
    catch (error) {
        utils_2.logger.error(error);
        throw error;
    }
}
exports.describeCluster = describeCluster;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1wb3J0LWNsdXN0ZXItcHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9saWIvY2x1c3Rlci1wcm92aWRlcnMvaW1wb3J0LWNsdXN0ZXItcHJvdmlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsZ0NBQXNEO0FBQ3RELHlFQUFnRTtBQUVoRSwyQ0FBMkM7QUFHM0MsMkNBQTJDO0FBRTNDLHVEQUEwRDtBQUMxRCw4REFBb0U7QUFDcEUsb0NBQWtDO0FBYWxDOzs7R0FHRztBQUNILE1BQWEscUJBQXFCO0lBRTlCLFlBQTZCLEtBQWlDO1FBQWpDLFVBQUssR0FBTCxLQUFLLENBQTRCO0lBQUksQ0FBQztJQUVuRTs7Ozs7O09BTUc7SUFDSCxhQUFhLENBQUMsS0FBZ0IsRUFBRSxHQUFTLEVBQUUscUJBQXdDO1FBQy9FLE1BQU0sS0FBSyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxDQUFDO1FBRXJDLElBQUcsQ0FBRSxLQUFLLENBQUMsWUFBWSxFQUFFO1lBQ3JCLEtBQUssQ0FBQyxZQUFZLEdBQUcsSUFBQSw2Q0FBa0IsRUFBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ2pFO1FBRUQsTUFBTSxlQUFlLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDdEgsT0FBTyxJQUFJLGlCQUFXLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUdEOzs7Ozs7OztPQVFHO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxXQUFtQixFQUFFLE1BQWMsRUFBRSxXQUFrQjtRQUd6RixNQUFNLFVBQVUsR0FBRyxNQUFNLGVBQWUsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQkFBbUIsQ0FBQyxDQUFDO1FBQ3ZGLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMscUJBQXFCLENBQUMsVUFBdUIsRUFBRSxXQUFrQjs7UUFDM0UsT0FBTyxJQUFJLHFCQUFxQixDQUFDO1lBQzdCLFdBQVcsRUFBRSxVQUFVLENBQUMsSUFBSztZQUM3QixPQUFPLEVBQUUsR0FBRyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBUSxDQUFDO1lBQ3RELGVBQWUsRUFBRSxVQUFVLENBQUMsUUFBUTtZQUNwQyxxQkFBcUIsRUFBRSxJQUFBLG1CQUFXLEVBQUMsT0FBTyxDQUFDLEVBQUUsQ0FDekMsSUFBSSxnREFBMkIsQ0FBQyxVQUFVLENBQUMsUUFBUyxDQUFDLElBQUssQ0FBQyxNQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDekYsK0JBQStCLEVBQUUsTUFBQSxVQUFVLENBQUMsb0JBQW9CLDBDQUFFLElBQUk7WUFDdEUsY0FBYyxFQUFFLFdBQVcsQ0FBQyxPQUFPO1lBQ25DLHNCQUFzQixFQUFFLE1BQUEsVUFBVSxDQUFDLGtCQUFrQiwwQ0FBRSxzQkFBc0I7WUFDN0UsZ0JBQWdCLEVBQUUsTUFBQSxVQUFVLENBQUMsa0JBQWtCLDBDQUFFLGdCQUFnQjtTQUNwRSxDQUFDLENBQUM7SUFDUCxDQUFDO0NBQ0o7QUExREQsc0RBMERDO0FBRUQ7Ozs7O0dBS0c7QUFDSSxLQUFLLFVBQVUsZUFBZSxDQUFDLFdBQW1CLEVBQUUsTUFBYztJQUNyRSxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQzdDLE1BQU0sS0FBSyxHQUErQjtRQUN0QyxJQUFJLEVBQUUsV0FBVztLQUNwQixDQUFDO0lBRUYsTUFBTSxPQUFPLEdBQUcsSUFBSSxHQUFHLENBQUMsc0JBQXNCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdEQsSUFBSTtRQUNBLE1BQU0sUUFBUSxHQUFHLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM1QyxPQUFPLFFBQVEsQ0FBQyxPQUFRLENBQUM7S0FDNUI7SUFDRCxPQUFPLEtBQUssRUFBRTtRQUNWLGNBQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEIsTUFBTSxLQUFLLENBQUM7S0FDZjtBQUNMLENBQUM7QUFmRCwwQ0FlQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENsdXN0ZXJJbmZvLCBDbHVzdGVyUHJvdmlkZXIgfSBmcm9tIFwiLi4vc3BpXCI7XG5pbXBvcnQgeyBzZWxlY3RLdWJlY3RsTGF5ZXIgfSBmcm9tIFwiLi9nZW5lcmljLWNsdXN0ZXItcHJvdmlkZXJcIjtcbmltcG9ydCB7IElWcGMgfSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWVjMlwiO1xuaW1wb3J0ICogYXMgZWtzIGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtZWtzXCI7XG5pbXBvcnQgeyBJUm9sZSB9IGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtaWFtXCI7XG5pbXBvcnQgeyBJS2V5IH0gZnJvbSBcImF3cy1jZGstbGliL2F3cy1rbXNcIjtcbmltcG9ydCAqIGFzIHNkayBmcm9tIFwiQGF3cy1zZGsvY2xpZW50LWVrc1wiO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCB7IGdldFJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlLXByb3ZpZGVycy91dGlsc1wiO1xuaW1wb3J0IHsgTG9va3VwT3BlbklkQ29ubmVjdFByb3ZpZGVyIH0gZnJvbSBcIi4uL3Jlc291cmNlLXByb3ZpZGVyc1wiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9iamVjdCBmb3IgdGhlIEltcG9ydENsdXN0ZXJQcm92aWRlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRDbHVzdGVyUHJvdmlkZXJQcm9wcyBleHRlbmRzIE9taXQ8ZWtzLkNsdXN0ZXJBdHRyaWJ1dGVzLCBcInZwY1wiPiB7XG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyBuZWVkZWQgYXMgaXQgZHJpdmVzIHNlbGVjdGlvbiBvZiBjZXJ0YWluIGFkZC1vbiB2ZXJzaW9ucyBhcyB3ZWxsIGFzIGt1YmVjdGwgbGF5ZXIuIFxuICAgICAqL1xuICAgIHZlcnNpb246IGVrcy5LdWJlcm5ldGVzVmVyc2lvbjtcbn1cblxuLyoqXG4gKiBJbXBvcnRpbmcgY2x1c3RlciBpbnRvIHRoZSBibHVlcHJpbnQgZW5hYmxpbmcgbGltaXRlZCBibHVlcHJpbnRpbmcgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgYWRkaW5nIGNlcnRhaW4gYWRkb25zLCBcbiAqIHRlYW1zLlxuICovXG5leHBvcnQgY2xhc3MgSW1wb3J0Q2x1c3RlclByb3ZpZGVyIGltcGxlbWVudHMgQ2x1c3RlclByb3ZpZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IEltcG9ydENsdXN0ZXJQcm92aWRlclByb3BzKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgY29udHJhY3QgbWV0aG9kIHRvIGNyZWF0ZSBhIGNsdXN0ZXIsIGJ5IGltcG9ydGluZyBhbiBleGlzdGluZyBjbHVzdGVyLlxuICAgICAqIEBwYXJhbSBzY29wZSBcbiAgICAgKiBAcGFyYW0gdnBjIFxuICAgICAqIEBwYXJhbSBfc2VjcmV0c0VuY3J5cHRpb25LZXkgXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgY3JlYXRlQ2x1c3RlcihzY29wZTogQ29uc3RydWN0LCB2cGM6IElWcGMsIF9zZWNyZXRzRW5jcnlwdGlvbktleT86IElLZXkgfCB1bmRlZmluZWQpOiBDbHVzdGVySW5mbyB7XG4gICAgICAgIGNvbnN0IHByb3BzID0geyAuLi50aGlzLnByb3BzLCB2cGMgfTtcblxuICAgICAgICBpZighIHByb3BzLmt1YmVjdGxMYXllcikge1xuICAgICAgICAgICAgcHJvcHMua3ViZWN0bExheWVyID0gc2VsZWN0S3ViZWN0bExheWVyKHNjb3BlLCBwcm9wcy52ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDbHVzdGVyID0gZWtzLkNsdXN0ZXIuZnJvbUNsdXN0ZXJBdHRyaWJ1dGVzKHNjb3BlLCAnaW1wb3J0ZWQtY2x1c3Rlci0nICsgdGhpcy5wcm9wcy5jbHVzdGVyTmFtZSwgcHJvcHMpO1xuICAgICAgICByZXR1cm4gbmV3IENsdXN0ZXJJbmZvKGV4aXN0aW5nQ2x1c3RlciwgdGhpcy5wcm9wcy52ZXJzaW9uKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVzIGlhbSBwZXJtaXNzaW9uIHRvIGVrcy5EZXNjcmliZUNsdXN0ZXIgYXQgYnVpbGQgdGltZS4gUmV0cmlldmVzIHRoZSBjbHVzdGVyIGluZm9ybWF0aW9uIHVzaW5nIERlc2NyaWJlQ2x1c3RlciBhcGkgYW5kXG4gICAgICogY3JlYXRlcyBhbiBpbXBvcnQgY2x1c3RlciBwcm92aWRlci4gXG4gICAgICogQHBhcmFtIGNsdXN0ZXJOYW1lIG5hbWUgb2YgdGhlIGNsdXN0ZXJcbiAgICAgKiBAcGFyYW0gcmVnaW9uIHRhcmdldCByZWdvXG4gICAgICogQHBhcmFtIGt1YmVjdGxSb2xlIGlhbSBSb2xlIHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBjbHVzdGVyIEFQSSAoa3ViZWN0bCkuIFRoZSBDREsgY3VzdG9tIHJlc291cmNlIHNob3VsZCBiZSBhYmxlIHRvIGFzc3VtZSB0aGUgcm9sZVxuICAgICAqIHdoaWNoIGluIHNvbWUgY2FzZXMgbWF5IHJlcXVpcmUgdHJ1c3QgcG9saWN5IGZvciB0aGUgYWNjb3VudCByb290IHByaW5jaXBhbC5cbiAgICAgKiBAcmV0dXJucyB0aGUgY2x1c3RlciBwcm92aWRlciB3aXRoIHRoZSBpbXBvcnQgY2x1c3RlciBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBmcm9tQ2x1c3Rlckxvb2t1cChjbHVzdGVyTmFtZTogc3RyaW5nLCByZWdpb246IHN0cmluZywga3ViZWN0bFJvbGU6IElSb2xlKTogXG4gICAgICAgIFByb21pc2U8Q2x1c3RlclByb3ZpZGVyPiB7XG5cbiAgICAgICAgY29uc3Qgc2RrQ2x1c3RlciA9IGF3YWl0IGRlc2NyaWJlQ2x1c3RlcihjbHVzdGVyTmFtZSwgcHJvY2Vzcy5lbnYuQ0RLX0RFRkFVTFRfUkVHSU9OISk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21DbHVzdGVyQXR0cmlidXRlcyhzZGtDbHVzdGVyLCBrdWJlY3RsUm9sZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsdXN0ZXIgcHJvdmlkZXIgZm9yIGFuIGV4aXN0aW5nIGNsdXN0ZXIgYmFzZWQgb24gdGhlIHBhc3NlZCByZXN1bHQgb2YgdGhlIGRlc2NyaWJlIGNsdXN0ZXIgY29tbWFuZC5cbiAgICAgKiBAcGFyYW0gc2RrQ2x1c3RlciBcbiAgICAgKiBAcGFyYW0ga3ViZWN0bFJvbGUgXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBmcm9tQ2x1c3RlckF0dHJpYnV0ZXMoc2RrQ2x1c3Rlcjogc2RrLkNsdXN0ZXIsIGt1YmVjdGxSb2xlOiBJUm9sZSk6IENsdXN0ZXJQcm92aWRlciB7XG4gICAgICAgIHJldHVybiBuZXcgSW1wb3J0Q2x1c3RlclByb3ZpZGVyKHtcbiAgICAgICAgICAgIGNsdXN0ZXJOYW1lOiBzZGtDbHVzdGVyLm5hbWUhLFxuICAgICAgICAgICAgdmVyc2lvbjogZWtzLkt1YmVybmV0ZXNWZXJzaW9uLm9mKHNka0NsdXN0ZXIudmVyc2lvbiEpLFxuICAgICAgICAgICAgY2x1c3RlckVuZHBvaW50OiBzZGtDbHVzdGVyLmVuZHBvaW50LFxuICAgICAgICAgICAgb3BlbklkQ29ubmVjdFByb3ZpZGVyOiBnZXRSZXNvdXJjZShjb250ZXh0ID0+XG4gICAgICAgICAgICAgICAgbmV3IExvb2t1cE9wZW5JZENvbm5lY3RQcm92aWRlcihzZGtDbHVzdGVyLmlkZW50aXR5IS5vaWRjIS5pc3N1ZXIhKS5wcm92aWRlKGNvbnRleHQpKSxcbiAgICAgICAgICAgIGNsdXN0ZXJDZXJ0aWZpY2F0ZUF1dGhvcml0eURhdGE6IHNka0NsdXN0ZXIuY2VydGlmaWNhdGVBdXRob3JpdHk/LmRhdGEsXG4gICAgICAgICAgICBrdWJlY3RsUm9sZUFybjoga3ViZWN0bFJvbGUucm9sZUFybixcbiAgICAgICAgICAgIGNsdXN0ZXJTZWN1cml0eUdyb3VwSWQ6IHNka0NsdXN0ZXIucmVzb3VyY2VzVnBjQ29uZmlnPy5jbHVzdGVyU2VjdXJpdHlHcm91cElkLFxuICAgICAgICAgICAgc2VjdXJpdHlHcm91cElkczogc2RrQ2x1c3Rlci5yZXNvdXJjZXNWcGNDb25maWc/LnNlY3VyaXR5R3JvdXBJZHNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFdyYXBzIEFQSSBjYWxsIHRvIGdldCB0aGUgZGF0YSBvbiB0aGUgZWtzLkNsdXN0ZXIuIFxuICogQHBhcmFtIGNsdXN0ZXJOYW1lIFxuICogQHBhcmFtIHJlZ2lvbiBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVzY3JpYmVDbHVzdGVyKGNsdXN0ZXJOYW1lOiBzdHJpbmcsIHJlZ2lvbjogc3RyaW5nKTogUHJvbWlzZTxzZGsuQ2x1c3Rlcj4ge1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBzZGsuRUtTQ2xpZW50KHsgcmVnaW9uIH0pO1xuICAgIGNvbnN0IGlucHV0OiBzZGsuRGVzY3JpYmVDbHVzdGVyUmVxdWVzdCA9IHtcbiAgICAgICAgbmFtZTogY2x1c3Rlck5hbWVcbiAgICB9O1xuXG4gICAgY29uc3QgY29tbWFuZCA9IG5ldyBzZGsuRGVzY3JpYmVDbHVzdGVyQ29tbWFuZChpbnB1dCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuc2VuZChjb21tYW5kKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmNsdXN0ZXIhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufSJdfQ==