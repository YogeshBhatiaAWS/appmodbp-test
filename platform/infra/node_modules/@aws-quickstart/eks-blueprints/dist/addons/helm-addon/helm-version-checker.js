"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkHelmChartVersion = exports.listChartVersions = void 0;
const utils_1 = require("../../utils");
/**
 * Semver comparator, simplistic implementation. Might require additional
 * logic for correct semver comparison.
 *
 * @param a
 * @param b
 * @returns
 */
const semverComparator = (a, b) => {
    a = trimVersion(a);
    b = trimVersion(b);
    const a1 = a.split('.');
    const b1 = b.split('.');
    const len = Math.min(a1.length, b1.length);
    for (let i = 0; i < len; i++) {
        const a2 = +a1[i] || 0;
        const b2 = +b1[i] || 0;
        if (a2 !== b2) {
            return a2 > b2 ? -1 : 1;
        }
    }
    return b1.length - a1.length;
};
/**
 * Remove leading "v". Placeholder to extend (e.g. remove -rc, -beta, etc.);
 * @param v semver format version
 * @returns
 */
function trimVersion(v) {
    return v.charAt(0) == 'v' ? v.substring(1) : v;
}
/**
 * Lists chart versions for a given helm chart.
 * @param chart
 * @returns
 */
function listChartVersions(chart) {
    // TODO make function async and use async HTTP client to get results
    if (chart.repository) {
        if (chart.repository.startsWith("oci:")) {
            return []; // skip for now if OCI repo
        }
        const helmRepository = (0, utils_1.loadExternalYaml)(chart.repository + "/index.yaml");
        const versions = Object.values(helmRepository[0]['entries'][chart.chart])
            .map((e) => { return e['version']; });
        // TODO: refactor to support dictionary of keywords that qualify as non-production
        return versions.filter(e => e.includes(".") && !e.includes("beta") && !e.includes("alpha") && !e.includes("dev") && !e.includes("rc"));
    }
    else {
        return [];
    }
}
exports.listChartVersions = listChartVersions;
/**
 * Checks the provided helm chart version against the repository.
 * Validation is successful if there is no higher version registered in the repository.
 * @param chart
 * @returns
 */
function checkHelmChartVersion(chart) {
    let versions = listChartVersions(chart);
    if (versions === null || versions.length == 0) {
        console.warn("No versions are found for " + chart.chart + " in repository " + chart.repository);
        return {
            allVersions: versions,
            highestVersion: undefined,
            latestVersion: false
        };
    }
    versions = versions.sort(semverComparator);
    const latestVersion = (trimVersion(versions[0]) === trimVersion(chart.version));
    if (latestVersion) {
        utils_1.userLog.info(`Chart ${chart.chart}-${chart.version} is at the latest version.`);
    }
    else {
        utils_1.userLog.warn(`Upgrade is needed for chart ${chart.chart}-${chart.version}: latest version is ${versions[0]}.`);
    }
    return {
        allVersions: versions,
        highestVersion: versions[0],
        latestVersion: latestVersion
    };
}
exports.checkHelmChartVersion = checkHelmChartVersion;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVsbS12ZXJzaW9uLWNoZWNrZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRkb25zL2hlbG0tYWRkb24vaGVsbS12ZXJzaW9uLWNoZWNrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsdUNBQXdEO0FBS3hEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLGdCQUFnQixHQUFHLENBQUMsQ0FBUyxFQUFFLENBQVMsRUFBRSxFQUFFO0lBQzlDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkIsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVuQixNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFeEIsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQzFCLE1BQU0sRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFFLENBQUMsQ0FBRSxJQUFJLENBQUMsQ0FBQztRQUN6QixNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBRSxDQUFDLENBQUUsSUFBSSxDQUFDLENBQUM7UUFFekIsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ1gsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzNCO0tBQ0o7SUFFRCxPQUFPLEVBQUUsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQztBQUNqQyxDQUFDLENBQUM7QUFFRjs7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aW1wb3J0IHsgbG9hZEV4dGVybmFsWWFtbCwgdXNlckxvZyB9IGZyb20gXCIuLi8uLi91dGlsc1wiO1xuaW1wb3J0IHsgSGVsbUNoYXJ0Q29uZmlndXJhdGlvbiB9IGZyb20gXCIuL2t1YmVjdGwtcHJvdmlkZXJcIjtcblxuZXhwb3J0IHR5cGUgSGVsbUNoYXJ0VmVyc2lvbiA9IE9taXQ8SGVsbUNoYXJ0Q29uZmlndXJhdGlvbiwgXCJuYW1lXCIgfCBcIm5hbWVzcGFjZVwiIHwgIFwicmVsZWFzZVwiIHwgXCJ2YWx1ZXNcIj47XG5cbi8qKlxuICogU2VtdmVyIGNvbXBhcmF0b3IsIHNpbXBsaXN0aWMgaW1wbGVtZW50YXRpb24uIE1pZ2h0IHJlcXVpcmUgYWRkaXRpb25hbCBcbiAqIGxvZ2ljIGZvciBjb3JyZWN0IHNlbXZlciBjb21wYXJpc29uLlxuICogXG4gKiBAcGFyYW0gYSBcbiAqIEBwYXJhbSBiIFxuICogQHJldHVybnMgXG4gKi9cbmNvbnN0IHNlbXZlckNvbXBhcmF0b3IgPSAoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IHsgXG4gICAgYSA9IHRyaW1WZXJzaW9uKGEpO1xuICAgIGIgPSB0cmltVmVyc2lvbihiKTtcblxuICAgIGNvbnN0IGExID0gYS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGIxID0gYi5zcGxpdCgnLicpO1xuXG4gICAgY29uc3QgbGVuID0gTWF0aC5taW4oYTEubGVuZ3RoLCBiMS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYTIgPSArYTFbIGkgXSB8fCAwO1xuICAgICAgICBjb25zdCBiMiA9ICtiMVsgaSBdIHx8IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoYTIgIT09IGIyKSB7XG4gICAgICAgICAgICByZXR1cm4gYTIgPiBiMiA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiMS5sZW5ndGggLSBhMS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBsZWFkaW5nIFwidlwiLiBQbGFjZWhvbGRlciB0byBleHRlbmQgKGUuZy4gcmVtb3ZlIC1yYywgLWJldGEsIGV0Yy4pO1xuICogQHBhcmFtIHYgc2VtdmVyIGZvcm1hdCB2ZXJzaW9uXG4gKiBAcmV0dXJucyBcbiAqL1xuZnVuY3Rpb24gdHJpbVZlcnNpb24odjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHYuY2hhckF0KDApID09ICAndicgPyB2LnN1YnN0cmluZygxKSA6IHY7XG59XG4vKipcbiAqIFJlcHJlc2VudCByZXN1bHQgb2YgaGVsbSBjaGFydCB2ZXJzaW9uIHZhbGlkYXRpb24gYWdhaW5zdCBuZXdlciB2ZXJzaW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrVmVyc2lvblJlc3VsdCB7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyB0aGUgaGlnaGVzdCB2ZXJzaW9uIG9mIHRoZSBoZWxtIGNoYXJ0IGRpc2NvdmVyZWQgaW4gdGhlIGhlbG0gY2hhcnQgcmVwb3NpdG9yeS5cbiAgICAgKi9cbiAgICBoaWdoZXN0VmVyc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIFxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHByb3ZpZGVkIHZlcnNpb24gaXMgdGhlIGxhdGVzdCB2ZXJzaW9uIGluIHRoZSBoZWxtIGNoYXJ0IHJlcG9zaXRvcnkuIE90aGVyd2lzZSwgZmFsc2UuXG4gICAgICovXG4gICAgbGF0ZXN0VmVyc2lvbjogYm9vbGVhbixcblxuICAgIC8qKlxuICAgICAqIEFsbCBkaXNjb3ZlcmVkIHZlcnNpb25zIG9mIHRoZSBjaGFydCwgZGlzY292ZXJlZCBpbiB0aGUgcHJvdmlkZWQgaGVsbSBjaGFydCByZXBvc2l0b3J5LlxuICAgICAqL1xuICAgIGFsbFZlcnNpb25zOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBMaXN0cyBjaGFydCB2ZXJzaW9ucyBmb3IgYSBnaXZlbiBoZWxtIGNoYXJ0LlxuICogQHBhcmFtIGNoYXJ0IFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0Q2hhcnRWZXJzaW9ucyhjaGFydDogSGVsbUNoYXJ0VmVyc2lvbik6IHN0cmluZ1tdIHtcbiAgICAvLyBUT0RPIG1ha2UgZnVuY3Rpb24gYXN5bmMgYW5kIHVzZSBhc3luYyBIVFRQIGNsaWVudCB0byBnZXQgcmVzdWx0c1xuICAgIGlmIChjaGFydC5yZXBvc2l0b3J5KSB7XG4gICAgICAgIGlmIChjaGFydC5yZXBvc2l0b3J5IS5zdGFydHNXaXRoKFwib2NpOlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBza2lwIGZvciBub3cgaWYgT0NJIHJlcG9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWxtUmVwb3NpdG9yeSA9IGxvYWRFeHRlcm5hbFlhbWwoY2hhcnQucmVwb3NpdG9yeSArIFwiL2luZGV4LnlhbWxcIik7XG4gICAgICAgIGNvbnN0IHZlcnNpb25zOiBzdHJpbmdbXSA9IE9iamVjdC52YWx1ZXMoaGVsbVJlcG9zaXRvcnlbMF1bJ2VudHJpZXMnXVtjaGFydC5jaGFydF0pXG4gICAgICAgICAgICAubWFwKChlOiBhbnkpID0+IHsgcmV0dXJuIGVbJ3ZlcnNpb24nXTsgfSk7XG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIHN1cHBvcnQgZGljdGlvbmFyeSBvZiBrZXl3b3JkcyB0aGF0IHF1YWxpZnkgYXMgbm9uLXByb2R1Y3Rpb25cbiAgICAgICAgcmV0dXJuIHZlcnNpb25zLmZpbHRlcihlID0+IGUuaW5jbHVkZXMoXCIuXCIpICYmICFlLmluY2x1ZGVzKFwiYmV0YVwiKSAmJiAhZS5pbmNsdWRlcyhcImFscGhhXCIpICYmICFlLmluY2x1ZGVzKFwiZGV2XCIpICYmICFlLmluY2x1ZGVzKFwicmNcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIHRoZSBwcm92aWRlZCBoZWxtIGNoYXJ0IHZlcnNpb24gYWdhaW5zdCB0aGUgcmVwb3NpdG9yeS5cbiAqIFZhbGlkYXRpb24gaXMgc3VjY2Vzc2Z1bCBpZiB0aGVyZSBpcyBubyBoaWdoZXIgdmVyc2lvbiByZWdpc3RlcmVkIGluIHRoZSByZXBvc2l0b3J5LiBcbiAqIEBwYXJhbSBjaGFydCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tIZWxtQ2hhcnRWZXJzaW9uKGNoYXJ0OiBIZWxtQ2hhcnRWZXJzaW9uKSA6IENoZWNrVmVyc2lvblJlc3VsdCB7XG4gICAgbGV0IHZlcnNpb25zID0gbGlzdENoYXJ0VmVyc2lvbnMoY2hhcnQpO1xuICAgIGlmKHZlcnNpb25zID09PSBudWxsIHx8IHZlcnNpb25zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vIHZlcnNpb25zIGFyZSBmb3VuZCBmb3IgXCIgKyBjaGFydC5jaGFydCArIFwiIGluIHJlcG9zaXRvcnkgXCIgKyBjaGFydC5yZXBvc2l0b3J5ICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxWZXJzaW9uczogdmVyc2lvbnMsXG4gICAgICAgICAgICBoaWdoZXN0VmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGF0ZXN0VmVyc2lvbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmVyc2lvbnMgPSB2ZXJzaW9ucy5zb3J0KHNlbXZlckNvbXBhcmF0b3IpO1xuICAgIGNvbnN0IGxhdGVzdFZlcnNpb24gPSAodHJpbVZlcnNpb24odmVyc2lvbnNbMF0pID09PSB0cmltVmVyc2lvbihjaGFydC52ZXJzaW9uKSk7XG4gICAgaWYobGF0ZXN0VmVyc2lvbikge1xuICAgICAgICB1c2VyTG9nLmluZm8oYENoYXJ0ICR7Y2hhcnQuY2hhcnR9LSR7Y2hhcnQudmVyc2lvbn0gaXMgYXQgdGhlIGxhdGVzdCB2ZXJzaW9uLmAgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVzZXJMb2cud2FybihgVXBncmFkZSBpcyBuZWVkZWQgZm9yIGNoYXJ0ICR7Y2hhcnQuY2hhcnR9LSR7Y2hhcnQudmVyc2lvbn06IGxhdGVzdCB2ZXJzaW9uIGlzICR7dmVyc2lvbnNbMF19LmApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxWZXJzaW9uczogdmVyc2lvbnMsXG4gICAgICAgIGhpZ2hlc3RWZXJzaW9uOiB2ZXJzaW9uc1swXSxcbiAgICAgICAgbGF0ZXN0VmVyc2lvbjogbGF0ZXN0VmVyc2lvblxuICAgIH07XG59Il19