"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KNativeOperator = void 0;
const utils_1 = require("../../utils");
const kubectl_provider_1 = require("../helm-addon/kubectl-provider");
const defaultProps = {
    name: 'knative-operator',
    namespace: 'default',
    version: 'v1.8.1',
};
/**
 * Implementation of KNative add-on for EKS Blueprints. Installs KNative to the Cluster.
 */
class KNativeOperator {
    constructor(props) {
        this.knativeAddOnProps = { ...defaultProps, ...props };
    }
    deploy(clusterInfo) {
        const BASE_URL = `https://github.com/knative/operator/releases/download/knative`;
        // Load External YAML: https://github.com/knative/operator/releases/download/knative-v1.8.1/operator.yaml
        const doc = (0, utils_1.loadExternalYaml)(BASE_URL + `-${this.knativeAddOnProps.version}/operator.yaml`).slice(0, 26); // the last element is null
        const kubectlProvider = new kubectl_provider_1.KubectlProvider(clusterInfo);
        const statement = kubectlProvider.addManifest({ manifest: doc, values: {}, name: 'knative-operator', namespace: this.knativeAddOnProps.namespace });
        return Promise.resolve(statement);
    }
}
exports.KNativeOperator = KNativeOperator;
__decorate([
    (0, utils_1.dependable)('IstioControlPlaneAddOn')
], KNativeOperator.prototype, "deploy", null);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRkb25zL2tuYXRpdmUtb3BlcmF0b3IvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRUEsdUNBQXlEO0FBRXpELHFFQUFpRTtBQXlCakUsTUFBTSxZQUFZLEdBQUc7SUFDakIsSUFBSSxFQUFFLGtCQUFrQjtJQUN4QixTQUFTLEVBQUUsU0FBUztJQUNwQixPQUFPLEVBQUUsUUFBUTtDQUNwQixDQUFDO0FBRUY7O0dBRUc7QUFDSCxNQUFhLGVBQWU7SUFJeEIsWUFBWSxLQUE0QjtRQUNwQyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxHQUFHLFlBQVksRUFBRSxHQUFHLEtBQUssRUFBRSxDQUFDO0lBQzNELENBQUM7SUFHRCxNQUFNLENBQUMsV0FBd0I7UUFDM0IsTUFBTSxRQUFRLEdBQUcsK0RBQStELENBQUM7UUFFakYseUdBQXlHO1FBQ3pHLE1BQU0sR0FBRyxHQUFHLElBQUEsd0JBQWdCLEVBQ3hCLFFBQVEsR0FBRyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLGdCQUFnQixDQUNoRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQywyQkFBMkI7UUFFM0MsTUFBTSxlQUFlLEdBQUcsSUFBSSxrQ0FBZSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXpELE1BQU0sU0FBUyxHQUFHLGVBQWUsQ0FBQyxXQUFXLENBQ3pDLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxrQkFBa0IsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFNBQVUsRUFBRSxDQUN4RyxDQUFDO1FBRUYsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7Q0FDSjtBQXpCRCwwQ0F5QkM7QUFoQkc7SUFEQyxJQUFBLGtCQUFVLEVBQUMsd0JBQXdCLENBQUM7NkNBZ0JwQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuaW1wb3J0IHsgQ2x1c3RlckFkZE9uLCBDbHVzdGVySW5mbyB9IGZyb20gXCIuLi8uLi9zcGlcIjtcbmltcG9ydCB7ZGVwZW5kYWJsZSwgbG9hZEV4dGVybmFsWWFtbH0gZnJvbSBcIi4uLy4uL3V0aWxzXCI7XG5pbXBvcnQgeyBIZWxtQWRkT25Vc2VyUHJvcHMgfSBmcm9tICcuLi9oZWxtLWFkZG9uJztcbmltcG9ydCB7IEt1YmVjdGxQcm92aWRlciB9IGZyb20gXCIuLi9oZWxtLWFkZG9uL2t1YmVjdGwtcHJvdmlkZXJcIjtcblxuLyoqXG4gKiBLbmF0aXZlIE9wZXJhdG9yIFByb3BlcnRpZXMgZXh0ZW5kZWQgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS25hdGl2ZU9wZXJhdG9yUHJvcHMgZXh0ZW5kcyBIZWxtQWRkT25Vc2VyUHJvcHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lc3BhY2UgdG8gaW5zdGFsbCBLbmF0aXZlIGluXG4gICAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgICAqL1xuICAgIG5hbWVzcGFjZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRvIGJlIGFzc2lnbmVkIHRvIGdpdmVuIHRvIHRoZSBLbmF0aXZlIG9wZXJhdG9yXG4gICAgICogQGRlZmF1bHQga25hdGl2ZS1vcGVyYXRvclxuICAgICAqL1xuICAgIG5hbWU/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgS05hdGl2ZSBPcGVyYXRvciB0byB1c2VcbiAgICAgKiBAZGVmYXVsdCB2MS44LjFcbiAgICAgKi9cbiAgICB2ZXJzaW9uPzogc3RyaW5nO1xufVxuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gICAgbmFtZTogJ2tuYXRpdmUtb3BlcmF0b3InLFxuICAgIG5hbWVzcGFjZTogJ2RlZmF1bHQnLFxuICAgIHZlcnNpb246ICd2MS44LjEnLFxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBLTmF0aXZlIGFkZC1vbiBmb3IgRUtTIEJsdWVwcmludHMuIEluc3RhbGxzIEtOYXRpdmUgdG8gdGhlIENsdXN0ZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBLTmF0aXZlT3BlcmF0b3IgaW1wbGVtZW50cyBDbHVzdGVyQWRkT24ge1xuXG4gICAgcmVhZG9ubHkga25hdGl2ZUFkZE9uUHJvcHM6IEtuYXRpdmVPcGVyYXRvclByb3BzO1xuXG4gICAgY29uc3RydWN0b3IocHJvcHM/OiBLbmF0aXZlT3BlcmF0b3JQcm9wcykge1xuICAgICAgICB0aGlzLmtuYXRpdmVBZGRPblByb3BzID0geyAuLi5kZWZhdWx0UHJvcHMsIC4uLnByb3BzIH07XG4gICAgfVxuXG4gICAgQGRlcGVuZGFibGUoJ0lzdGlvQ29udHJvbFBsYW5lQWRkT24nKVxuICAgIGRlcGxveShjbHVzdGVySW5mbzogQ2x1c3RlckluZm8pOiBQcm9taXNlPENvbnN0cnVjdD4ge1xuICAgICAgICBjb25zdCBCQVNFX1VSTCA9IGBodHRwczovL2dpdGh1Yi5jb20va25hdGl2ZS9vcGVyYXRvci9yZWxlYXNlcy9kb3dubG9hZC9rbmF0aXZlYDtcblxuICAgICAgICAvLyBMb2FkIEV4dGVybmFsIFlBTUw6IGh0dHBzOi8vZ2l0aHViLmNvbS9rbmF0aXZlL29wZXJhdG9yL3JlbGVhc2VzL2Rvd25sb2FkL2tuYXRpdmUtdjEuOC4xL29wZXJhdG9yLnlhbWxcbiAgICAgICAgY29uc3QgZG9jID0gbG9hZEV4dGVybmFsWWFtbChcbiAgICAgICAgICAgIEJBU0VfVVJMICsgYC0ke3RoaXMua25hdGl2ZUFkZE9uUHJvcHMudmVyc2lvbn0vb3BlcmF0b3IueWFtbGBcbiAgICAgICAgKS5zbGljZSgwLCAyNik7IC8vIHRoZSBsYXN0IGVsZW1lbnQgaXMgbnVsbFxuXG4gICAgICAgIGNvbnN0IGt1YmVjdGxQcm92aWRlciA9IG5ldyBLdWJlY3RsUHJvdmlkZXIoY2x1c3RlckluZm8pO1xuXG4gICAgICAgIGNvbnN0IHN0YXRlbWVudCA9IGt1YmVjdGxQcm92aWRlci5hZGRNYW5pZmVzdChcbiAgICAgICAgICAgIHsgbWFuaWZlc3Q6IGRvYywgdmFsdWVzOiB7fSwgbmFtZTogJ2tuYXRpdmUtb3BlcmF0b3InLCBuYW1lc3BhY2U6IHRoaXMua25hdGl2ZUFkZE9uUHJvcHMubmFtZXNwYWNlISB9XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdGF0ZW1lbnQpO1xuICAgIH1cbn1cbiJdfQ==