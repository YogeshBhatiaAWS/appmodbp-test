"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JupyterHubAddOn = exports.JupyterHubServiceType = void 0;
const assert = require("assert");
const utils_1 = require("../../utils");
const aws_loadbalancer_controller_1 = require("../aws-loadbalancer-controller");
const helm_addon_1 = require("../helm-addon");
const efs = require("aws-cdk-lib/aws-efs");
const ec2 = require("aws-cdk-lib/aws-ec2");
const semver = require("semver");
const ebs_csi_driver_1 = require("../ebs-csi-driver");
const efs_csi_driver_1 = require("../efs-csi-driver");
/**
 * Configuration options for exposing the JupyterHub proxy
 */
var JupyterHubServiceType;
(function (JupyterHubServiceType) {
    /**
     * Expose the service using AWS Application Load Balancer + Ingress controller
     */
    JupyterHubServiceType[JupyterHubServiceType["ALB"] = 0] = "ALB";
    /**
     * Expose the service using AWS Network Load Balancer + LoadBalancer service
     */
    JupyterHubServiceType[JupyterHubServiceType["NLB"] = 1] = "NLB";
    /**
     * Use ClusterIP service type and allow customers to port-forward for localhost access
     */
    JupyterHubServiceType[JupyterHubServiceType["CLUSTERIP"] = 2] = "CLUSTERIP";
})(JupyterHubServiceType || (exports.JupyterHubServiceType = JupyterHubServiceType = {}));
const JUPYTERHUB = 'jupyterhub';
const RELEASE = 'blueprints-addon-jupyterhub';
/**
 * Defaults options for the add-on
 */
const defaultProps = {
    name: JUPYTERHUB,
    namespace: JUPYTERHUB,
    version: '2.0.0',
    chart: JUPYTERHUB,
    release: RELEASE,
    repository: 'https://hub.jupyter.org/helm-chart/',
    values: {}
};
/**
 * Implementation of the JupyterHub add-on
 */
class JupyterHubAddOn extends helm_addon_1.HelmAddOn {
    constructor(props) {
        super({ ...defaultProps, ...props });
        this.options = this.props;
    }
    deploy(clusterInfo) {
        var _a;
        const cluster = clusterInfo.cluster;
        let values = (_a = this.options.values) !== null && _a !== void 0 ? _a : {};
        // The addon requires a persistent storage option
        assert(this.options.ebsConfig || this.options.efsConfig, "You need to provide a persistent storage option.");
        // But you can only provide one option for persistent storage
        assert(!(this.options.ebsConfig && this.options.efsConfig), "You cannot provide more than one persistent storage option.");
        // Create Namespace
        const ns = (0, utils_1.createNamespace)(this.options.namespace, cluster, true, true);
        // User Environment setup
        let cmd;
        if (semver.lt(this.options.version, '2.0.0')) {
            cmd = ["start-singleuser.sh"];
        }
        else {
            cmd = ["jupyterhub-singleuser", "--allow-root"];
        }
        const notebook = this.options.notebookStack || 'jupyter/base-notebook';
        (0, utils_1.setPath)(values, "singleuser", {
            "image": {
                "name": `${notebook}`,
                "tag": "latest"
            },
            "extraEnv": { "CHOWN_HOME": "yes" },
            "uid": 0,
            "fsGid": 0,
            "cmd": cmd
        });
        // Persistent Storage Setup for EBS
        if (this.options.ebsConfig) {
            this.addEbsStorage(clusterInfo, values, this.options.ebsConfig);
        }
        // Persistent Storage Setup for EFS
        if (this.options.efsConfig) {
            this.addEfsStorage(clusterInfo, values, this.options.efsConfig);
        }
        // OpenID Connect authentication setup
        if (this.options.oidcConfig) {
            (0, utils_1.setPath)(values, "hub.config", {
                "JupyterHub": { "authenticator_class": "generic-oauth" },
                "GenericOAuthenticator": {
                    "client_id": this.options.oidcConfig.clientId,
                    "client_secret": this.options.oidcConfig.clientSecret,
                    "oauth_callback_url": this.options.oidcConfig.callbackUrl,
                    "authorize_url": this.options.oidcConfig.authUrl,
                    "token_url": this.options.oidcConfig.tokenUrl,
                    "userdata_url": this.options.oidcConfig.userDataUrl,
                    "scope": this.options.oidcConfig.scope,
                    "username_key": this.options.oidcConfig.usernameKey,
                }
            });
        }
        // Proxy information - set either ALB, NLB (default) or ClusterIP service based on 
        // provided configuration
        const serviceType = this.options.serviceType;
        const ingressHosts = this.options.ingressHosts || [];
        const ingressAnnotations = this.options.ingressAnnotations;
        const cert = this.options.certificateResourceName;
        const albAddOnCheck = clusterInfo.getScheduledAddOn(aws_loadbalancer_controller_1.AwsLoadBalancerControllerAddOn.name);
        // Use Ingress and AWS ALB
        if (serviceType == JupyterHubServiceType.ALB) {
            assert(albAddOnCheck, `Missing a dependency: ${aws_loadbalancer_controller_1.AwsLoadBalancerControllerAddOn.name}. Please add it to your list of addons.`);
            const presetAnnotations = {
                'alb.ingress.kubernetes.io/scheme': 'internet-facing',
                'alb.ingress.kubernetes.io/target-type': 'ip',
                'kubernetes.io/ingress.class': 'alb',
            };
            if (cert) {
                presetAnnotations['alb.ingress.kubernetes.io/ssl-redirect'] = '443';
                presetAnnotations['alb.ingress.kubernetes.io/listen-ports'] = '[{"HTTP": 80},{"HTTPS":443}]';
                const certificate = clusterInfo.getResource(cert);
                presetAnnotations['alb.ingress.kubernetes.io/certificate-arn'] = certificate === null || certificate === void 0 ? void 0 : certificate.certificateArn;
            }
            const annotations = { ...ingressAnnotations, ...presetAnnotations };
            (0, utils_1.setPath)(values, "ingress.annotations", annotations);
            (0, utils_1.setPath)(values, "ingress.hosts", ingressHosts);
            (0, utils_1.setPath)(values, "ingress.enabled", true);
            (0, utils_1.setPath)(values, "proxy.service", { "type": "ClusterIP" });
        }
        else {
            assert(!ingressHosts || ingressHosts.length == 0, 'Ingress Hosts CANNOT be assigned when ingress is disabled');
            assert(!ingressAnnotations, 'Ingress annotations CANNOT be assigned when ingress is disabled');
            assert(!cert, 'Cert option is only supported if ingress is enabled.');
            // If we set SVC, set the proxy service type to ClusterIP and allow users to port-forward to localhost
            if (serviceType == JupyterHubServiceType.CLUSTERIP) {
                (0, utils_1.setPath)(values, "proxy.service", { "type": "ClusterIP" });
                // We will use NLB 
            }
            else {
                assert(albAddOnCheck, `Missing a dependency: ${aws_loadbalancer_controller_1.AwsLoadBalancerControllerAddOn.name}. Please add it to your list of addons.`);
                (0, utils_1.setPath)(values, "proxy.service", {
                    "annotations": {
                        "service.beta.kubernetes.io/aws-load-balancer-type": "nlb",
                        "service.beta.kubernetes.io/aws-load-balancer-scheme": "internet-facing",
                        "service.beta.kubernetes.io/aws-load-balancer-nlb-target-type": "ip",
                    }
                });
            }
        }
        // Create Helm Chart
        const jupyterHubChart = this.addHelmChart(clusterInfo, values, false, false);
        // Add dependency
        jupyterHubChart.node.addDependency(ns);
        if (albAddOnCheck) {
            albAddOnCheck.then(construct => jupyterHubChart.node.addDependency(construct));
        }
        return Promise.resolve(jupyterHubChart);
    }
    /**
     * This is a helper function to create EBS persistent storage
     * @param {ClusterInfo} clusterInfo - Cluster Info
     * @param {string} values - Helm Chart Values
     * @param {string} ebsConfig - EBS Configurations supplied by user
     * @returns
     */
    addEbsStorage(clusterInfo, values, ebsConfig) {
        const dep = clusterInfo.getScheduledAddOn(ebs_csi_driver_1.EbsCsiDriverAddOn.name);
        assert(dep, `Missing a dependency: ${ebs_csi_driver_1.EbsCsiDriverAddOn.name}. Please add it to your list of addons.`);
        // Create persistent storage with EBS
        const storageClass = ebsConfig.storageClass;
        const ebsCapacity = ebsConfig.capacity;
        (0, utils_1.setPath)(values, "singleuser.storage", {
            "dynamic": { "storageClass": storageClass },
            "capacity": ebsCapacity
        });
    }
    /**
     * This is a helper function to create EFS persistent storage
     * @param {ClusterInfo} clusterInfo - Cluster Info
     * @param {string} values - Helm Chart Values
     * @param {string} efsConfig - EFS Configurations supplied by user
     * @returns
     */
    addEfsStorage(clusterInfo, values, efsConfig) {
        const dep = clusterInfo.getScheduledAddOn(efs_csi_driver_1.EfsCsiDriverAddOn.name);
        assert(dep, `Missing a dependency: ${efs_csi_driver_1.EfsCsiDriverAddOn.name}. Please add it to your list of addons.`);
        const pvcName = efsConfig.pvcName;
        const removalPolicy = efsConfig.removalPolicy;
        const efsCapacity = efsConfig.capacity;
        this.setupEFS(clusterInfo, this.options.namespace, pvcName, efsCapacity, removalPolicy);
        (0, utils_1.setPath)(values, "singleuser.storage", {
            "type": "static",
            "static": {
                "pvcName": `${pvcName}`,
                "subPath": "home/{username}"
            }
        });
    }
    /**
     * This is a helper function to use EFS as persistent storage
     * including necessary security group with ingress rule,
     * EFS File System, Kubernetes PV and PVC
     * @param {ClusterInfo} clusterInfo - Cluster Info
     * @param {string} namespace - Namespace
     * @param {string} pvcName - Name of the PV and PVC
     * @param {RemovalPolicy}removalPolicy - Removal Policy for EFS File System (RETAIN, DESTROY or SNAPSHOT)
     * @returns
     * */
    setupEFS(clusterInfo, namespace, pvcName, capacity, removalPolicy) {
        const cluster = clusterInfo.cluster;
        const clusterVpcCidr = clusterInfo.cluster.vpc.vpcCidrBlock;
        // Security Group required for access to the File System
        // With the right ingress rule
        const jupyterHubSG = new ec2.SecurityGroup(cluster.stack, 'MyEfsSecurityGroup', {
            vpc: clusterInfo.cluster.vpc,
            securityGroupName: "EksBlueprintsJHubEFSSG",
        });
        jupyterHubSG.addIngressRule(ec2.Peer.ipv4(clusterVpcCidr), new ec2.Port({
            protocol: ec2.Protocol.TCP,
            stringRepresentation: "EFSconnection",
            toPort: 2049,
            fromPort: 2049,
        }));
        // Create the EFS File System
        const jupyterHubFileSystem = new efs.FileSystem(cluster.stack, 'MyEfsFileSystem', {
            vpc: clusterInfo.cluster.vpc,
            securityGroup: jupyterHubSG,
            removalPolicy: removalPolicy,
        });
        const efsId = jupyterHubFileSystem.fileSystemId;
        // Create StorageClass
        const efsSC = cluster.addManifest('efs-storage-class', {
            apiVersion: 'storage.k8s.io/v1',
            kind: 'StorageClass',
            metadata: {
                name: 'efs-sc',
            },
            provisioner: 'efs.csi.aws.com',
        });
        // Setup PersistentVolume and PersistentVolumeClaim
        const efsPV = cluster.addManifest('efs-pv', {
            apiVersion: 'v1',
            kind: 'PersistentVolume',
            metadata: {
                name: `${pvcName}`,
                namespace: namespace
            },
            spec: {
                capacity: { storage: `${capacity}` },
                volumeMode: 'Filesystem',
                accessModes: ['ReadWriteMany'],
                storageClassName: 'efs-sc',
                csi: {
                    driver: 'efs.csi.aws.com',
                    volumeHandle: `${efsId}`,
                }
            },
        });
        efsPV.node.addDependency(efsSC);
        efsPV.node.addDependency(jupyterHubFileSystem);
        const efsPVC = cluster.addManifest('efs-pvc', {
            apiVersion: 'v1',
            kind: 'PersistentVolumeClaim',
            metadata: {
                name: `${pvcName}`,
                namespace: namespace
            },
            spec: {
                storageClassName: 'efs-sc',
                accessModes: ['ReadWriteMany'],
                resources: { requests: { storage: `${capacity}` } },
            },
        });
        efsPVC.node.addDependency(efsPV);
    }
}
exports.JupyterHubAddOn = JupyterHubAddOn;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRkb25zL2p1cHl0ZXJodWIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWlDO0FBR2pDLHVDQUF1RDtBQUN2RCxnRkFBZ0Y7QUFDaEYsOENBQThFO0FBRzlFLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFHM0MsaUNBQWlDO0FBQ2pDLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFFdEQ7O0dBRUc7QUFDSCxJQUFZLHFCQWVYO0FBZkQsV0FBWSxxQkFBcUI7SUFDN0I7O09BRUc7SUFDSCwrREFBRyxDQUFBO0lBRUg7O09BRUc7SUFDSCwrREFBRyxDQUFBO0lBRUg7O09BRUc7SUFDSCwyRUFBUyxDQUFBO0FBQ2IsQ0FBQyxFQWZXLHFCQUFxQixxQ0FBckIscUJBQXFCLFFBZWhDO0FBMkVELE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQztBQUNoQyxNQUFNLE9BQU8sR0FBRyw2QkFBNkIsQ0FBQztBQUU5Qzs7R0FFRztBQUNILE1BQU0sWUFBWSxHQUFtQjtJQUNqQyxJQUFJLEVBQUUsVUFBVTtJQUNoQixTQUFTLEVBQUUsVUFBVTtJQUNyQixPQUFPLEVBQUUsT0FBTztJQUNoQixLQUFLLEVBQUUsVUFBVTtJQUNqQixPQUFPLEVBQUUsT0FBTztJQUNoQixVQUFVLEVBQUUscUNBQXFDO0lBQ2pELE1BQU0sRUFBRSxFQUFFO0NBQ2IsQ0FBQztBQUVGOztHQUVHO0FBQ0gsTUFBYSxlQUFnQixTQUFRLHNCQUFTO0lBSTFDLFlBQVksS0FBNEI7UUFDcEMsS0FBSyxDQUFDLEVBQUMsR0FBRyxZQUFZLEVBQUUsR0FBRyxLQUFLLEVBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQTZCLENBQUM7SUFDdEQsQ0FBQztJQUVELE1BQU0sQ0FBQyxXQUF3Qjs7UUFDM0IsTUFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQztRQUNwQyxJQUFJLE1BQU0sR0FBRyxNQUFBLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxtQ0FBSSxFQUFFLENBQUM7UUFFdkMsaURBQWlEO1FBQ2pELE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxrREFBa0QsQ0FBQyxDQUFDO1FBRTdHLDZEQUE2RDtRQUM3RCxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsNkRBQTZELENBQUMsQ0FBQztRQUUzSCxtQkFBbUI7UUFDbkIsTUFBTSxFQUFFLEdBQUcsSUFBQSx1QkFBZSxFQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBVSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFekUseUJBQXlCO1FBQ3pCLElBQUksR0FBRyxDQUFDO1FBQ1IsSUFBSSxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBUSxFQUFFLE9BQU8sQ0FBQyxFQUFDO1lBQzFDLEdBQUcsR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUM7U0FDakM7YUFBTTtZQUNILEdBQUcsR0FBRyxDQUFDLHVCQUF1QixFQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQ2xEO1FBQ0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLElBQUksdUJBQXVCLENBQUM7UUFDdkUsSUFBQSxlQUFPLEVBQUMsTUFBTSxFQUFFLFlBQVksRUFBRTtZQUMxQixPQUFPLEVBQUM7Z0JBQ0osTUFBTSxFQUFFLEdBQUcsUUFBUSxFQUFFO2dCQUNyQixLQUFLLEVBQUUsUUFBUTthQUNsQjtZQUNELFVBQVUsRUFBRSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUU7WUFDbkMsS0FBSyxFQUFFLENBQUM7WUFDUixPQUFPLEVBQUUsQ0FBQztZQUNWLEtBQUssRUFBRSxHQUFHO1NBQ2IsQ0FBQyxDQUFDO1FBRUgsbUNBQW1DO1FBQ25DLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUM7WUFDdkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDbkU7UUFFRCxtQ0FBbUM7UUFDbkMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUN4QixJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUNuRTtRQUVELHNDQUFzQztRQUN0QyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFDO1lBQ3hCLElBQUEsZUFBTyxFQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUU7Z0JBQzFCLFlBQVksRUFBRSxFQUFFLHFCQUFxQixFQUFFLGVBQWUsRUFBRTtnQkFDeEQsdUJBQXVCLEVBQUU7b0JBQ3JCLFdBQVcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxRQUFRO29CQUM3QyxlQUFlLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsWUFBWTtvQkFDckQsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsV0FBVztvQkFDekQsZUFBZSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLE9BQU87b0JBQ2hELFdBQVcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxRQUFRO29CQUM3QyxjQUFjLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsV0FBVztvQkFDbkQsT0FBTyxFQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUs7b0JBQ3ZDLGNBQWMsRUFBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxXQUFXO2lCQUN2RDthQUNKLENBQUMsQ0FBQztTQUNOO1FBRUQsbUZBQW1GO1FBQ25GLHlCQUF5QjtRQUN6QixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQztRQUM3QyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUM7UUFDckQsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDO1FBQzNELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsdUJBQXVCLENBQUM7UUFFbEQsTUFBTSxhQUFhLEdBQUcsV0FBVyxDQUFDLGlCQUFpQixDQUFDLDREQUE4QixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pGLDBCQUEwQjtRQUMxQixJQUFJLFdBQVcsSUFBSSxxQkFBcUIsQ0FBQyxHQUFHLEVBQUM7WUFDekMsTUFBTSxDQUFDLGFBQWEsRUFBRSx5QkFBeUIsNERBQThCLENBQUMsSUFBSSx5Q0FBeUMsQ0FBQyxDQUFDO1lBQzdILE1BQU0saUJBQWlCLEdBQVE7Z0JBQzNCLGtDQUFrQyxFQUFFLGlCQUFpQjtnQkFDckQsdUNBQXVDLEVBQUUsSUFBSTtnQkFDN0MsNkJBQTZCLEVBQUUsS0FBSzthQUN2QyxDQUFDO1lBQ0YsSUFBSSxJQUFJLEVBQUM7Z0JBQ0wsaUJBQWlCLENBQUMsd0NBQXdDLENBQUMsR0FBRyxLQUFLLENBQUM7Z0JBQ3BFLGlCQUFpQixDQUFDLHdDQUF3QyxDQUFDLEdBQUcsOEJBQThCLENBQUM7Z0JBQzdGLE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQWUsSUFBSSxDQUFDLENBQUM7Z0JBQ2hFLGlCQUFpQixDQUFDLDJDQUEyQyxDQUFDLEdBQUcsV0FBVyxhQUFYLFdBQVcsdUJBQVgsV0FBVyxDQUFFLGNBQWMsQ0FBQzthQUNoRztZQUNELE1BQU0sV0FBVyxHQUFHLEVBQUUsR0FBRyxrQkFBa0IsRUFBRSxHQUFHLGlCQUFpQixFQUFDLENBQUM7WUFDbkUsSUFBQSxlQUFPLEVBQUMsTUFBTSxFQUFFLHFCQUFxQixFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQ3BELElBQUEsZUFBTyxFQUFDLE1BQU0sRUFBRSxlQUFlLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDL0MsSUFBQSxlQUFPLEVBQUMsTUFBTSxFQUFFLGlCQUFpQixFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3pDLElBQUEsZUFBTyxFQUFDLE1BQU0sRUFBRSxlQUFlLEVBQUUsRUFBQyxNQUFNLEVBQUcsV0FBVyxFQUFDLENBQUMsQ0FBQztTQUM1RDthQUFNO1lBQ0gsTUFBTSxDQUFDLENBQUMsWUFBWSxJQUFJLFlBQVksQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLDJEQUEyRCxDQUFDLENBQUM7WUFDL0csTUFBTSxDQUFDLENBQUMsa0JBQWtCLEVBQUUsaUVBQWlFLENBQUMsQ0FBQztZQUMvRixNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsc0RBQXNELENBQUMsQ0FBQztZQUN0RSxzR0FBc0c7WUFDdEcsSUFBSSxXQUFXLElBQUkscUJBQXFCLENBQUMsU0FBUyxFQUFDO2dCQUMvQyxJQUFBLGVBQU8sRUFBQyxNQUFNLEVBQUUsZUFBZSxFQUFFLEVBQUMsTUFBTSxFQUFFLFdBQVcsRUFBQyxDQUFDLENBQUM7Z0JBQzVELG1CQUFtQjthQUNsQjtpQkFBTTtnQkFDSCxNQUFNLENBQUMsYUFBYSxFQUFFLHlCQUF5Qiw0REFBOEIsQ0FBQyxJQUFJLHlDQUF5QyxDQUFDLENBQUM7Z0JBQzdILElBQUEsZUFBTyxFQUFDLE1BQU0sRUFBRSxlQUFlLEVBQUU7b0JBQzdCLGFBQWEsRUFBRTt3QkFDWCxtREFBbUQsRUFBRSxLQUFLO3dCQUMxRCxxREFBcUQsRUFBRSxpQkFBaUI7d0JBQ3hFLDhEQUE4RCxFQUFFLElBQUk7cUJBQ3ZFO2lCQUNKLENBQUMsQ0FBQzthQUNOO1NBQ0o7UUFFRCxvQkFBb0I7UUFDcEIsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUU3RSxpQkFBaUI7UUFDakIsZUFBZSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFdkMsSUFBRyxhQUFhLEVBQUU7WUFDZCxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztTQUNsRjtRQUNELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBQ0Q7Ozs7OztPQU1HO0lBQ08sYUFBYSxDQUFDLFdBQXdCLEVBQUUsTUFBVyxFQUFFLFNBQWM7UUFDekUsTUFBTSxHQUFHLEdBQUcsV0FBVyxDQUFDLGlCQUFpQixDQUFDLGtDQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xFLE1BQU0sQ0FBQyxHQUFHLEVBQUUseUJBQXlCLGtDQUFpQixDQUFDLElBQUkseUNBQXlDLENBQUMsQ0FBQztRQUN0RyxxQ0FBcUM7UUFDckMsTUFBTSxZQUFZLEdBQUcsU0FBUyxDQUFDLFlBQVksQ0FBQztRQUM1QyxNQUFNLFdBQVcsR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDO1FBQ3ZDLElBQUEsZUFBTyxFQUFDLE1BQU0sRUFBRSxvQkFBb0IsRUFBRTtZQUNsQyxTQUFTLEVBQUUsRUFBRSxjQUFjLEVBQUUsWUFBWSxFQUFFO1lBQzNDLFVBQVUsRUFBRSxXQUFXO1NBQzFCLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDTyxhQUFhLENBQUMsV0FBd0IsRUFBRSxNQUFXLEVBQUUsU0FBYztRQUN6RSxNQUFNLEdBQUcsR0FBRyxXQUFXLENBQUMsaUJBQWlCLENBQUMsa0NBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEUsTUFBTSxDQUFDLEdBQUcsRUFBRSx5QkFBeUIsa0NBQWlCLENBQUMsSUFBSSx5Q0FBeUMsQ0FBQyxDQUFDO1FBRXRHLE1BQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUM7UUFDbEMsTUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLGFBQWEsQ0FBQztRQUM5QyxNQUFNLFdBQVcsR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDO1FBRXZDLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBVSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDekYsSUFBQSxlQUFPLEVBQUMsTUFBTSxFQUFFLG9CQUFvQixFQUFFO1lBQ2xDLE1BQU0sRUFBRSxRQUFRO1lBQ2hCLFFBQVEsRUFBRTtnQkFDTixTQUFTLEVBQUUsR0FBRyxPQUFPLEVBQUU7Z0JBQ3ZCLFNBQVMsRUFBRSxpQkFBaUI7YUFDL0I7U0FDSixDQUFDLENBQUM7SUFDUCxDQUFDO0lBQ0Q7Ozs7Ozs7OztTQVNLO0lBQ0ssUUFBUSxDQUFDLFdBQXdCLEVBQUUsU0FBaUIsRUFBRSxPQUFlLEVBQUUsUUFBZ0IsRUFBRSxhQUFnQztRQUMvSCxNQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDO1FBQ3BDLE1BQU0sY0FBYyxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQztRQUU1RCx3REFBd0Q7UUFDeEQsOEJBQThCO1FBQzlCLE1BQU0sWUFBWSxHQUFHLElBQUksR0FBRyxDQUFDLGFBQWEsQ0FDdEMsT0FBTyxDQUFDLEtBQUssRUFBRSxvQkFBb0IsRUFDbkM7WUFDSSxHQUFHLEVBQUUsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHO1lBQzVCLGlCQUFpQixFQUFFLHdCQUF3QjtTQUM5QyxDQUNKLENBQUM7UUFDRixZQUFZLENBQUMsY0FBYyxDQUN2QixHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFDN0IsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDO1lBQ1QsUUFBUSxFQUFFLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRztZQUMxQixvQkFBb0IsRUFBRSxlQUFlO1lBQ3JDLE1BQU0sRUFBRSxJQUFJO1lBQ1osUUFBUSxFQUFFLElBQUk7U0FDakIsQ0FBQyxDQUNMLENBQUM7UUFFRiw2QkFBNkI7UUFDN0IsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQzNDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLEVBQ2hDO1lBQ0ksR0FBRyxFQUFFLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRztZQUM1QixhQUFhLEVBQUUsWUFBWTtZQUMzQixhQUFhLEVBQUUsYUFBYTtTQUMvQixDQUNKLENBQUM7UUFDRixNQUFNLEtBQUssR0FBRyxvQkFBb0IsQ0FBQyxZQUFZLENBQUM7UUFFaEQsc0JBQXNCO1FBQ3RCLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsbUJBQW1CLEVBQUU7WUFDbkQsVUFBVSxFQUFFLG1CQUFtQjtZQUMvQixJQUFJLEVBQUUsY0FBYztZQUNwQixRQUFRLEVBQUU7Z0JBQ04sSUFBSSxFQUFFLFFBQVE7YUFDakI7WUFDRCxXQUFXLEVBQUUsaUJBQWlCO1NBQ2pDLENBQUMsQ0FBQztRQUVILG1EQUFtRDtRQUNuRCxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRTtZQUN4QyxVQUFVLEVBQUUsSUFBSTtZQUNoQixJQUFJLEVBQUUsa0JBQWtCO1lBQ3hCLFFBQVEsRUFBRTtnQkFDTixJQUFJLEVBQUUsR0FBRyxPQUFPLEVBQUU7Z0JBQ2xCLFNBQVMsRUFBRSxTQUFTO2FBQ3ZCO1lBQ0QsSUFBSSxFQUFFO2dCQUNGLFFBQVEsRUFBRSxFQUFFLE9BQU8sRUFBRSxHQUFHLFFBQVEsRUFBRSxFQUFFO2dCQUNwQyxVQUFVLEVBQUUsWUFBWTtnQkFDeEIsV0FBVyxFQUFFLENBQUUsZUFBZSxDQUFFO2dCQUNoQyxnQkFBZ0IsRUFBRSxRQUFRO2dCQUMxQixHQUFHLEVBQUU7b0JBQ0QsTUFBTSxFQUFFLGlCQUFpQjtvQkFDekIsWUFBWSxFQUFFLEdBQUcsS0FBSyxFQUFFO2lCQUMzQjthQUNKO1NBQ0osQ0FBQyxDQUFDO1FBQ0gsS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDaEMsS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUUvQyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRTtZQUMxQyxVQUFVLEVBQUUsSUFBSTtZQUNoQixJQUFJLEVBQUUsdUJBQXVCO1lBQzdCLFFBQVEsRUFBRTtnQkFDTixJQUFJLEVBQUUsR0FBRyxPQUFPLEVBQUU7Z0JBQ2xCLFNBQVMsRUFBRSxTQUFTO2FBQ3ZCO1lBQ0QsSUFBSSxFQUFFO2dCQUNGLGdCQUFnQixFQUFFLFFBQVE7Z0JBQzFCLFdBQVcsRUFBRSxDQUFFLGVBQWUsQ0FBRTtnQkFDaEMsU0FBUyxFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUUsT0FBTyxFQUFFLEdBQUcsUUFBUSxFQUFFLEVBQUUsRUFBRTthQUN0RDtTQUNKLENBQUMsQ0FBQztRQUNILE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3JDLENBQUM7Q0FDSjtBQXBRRCwwQ0FvUUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCB7IENsdXN0ZXJJbmZvIH0gZnJvbSAnLi4vLi4vc3BpJztcbmltcG9ydCB7IGNyZWF0ZU5hbWVzcGFjZSwgc2V0UGF0aCB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IEF3c0xvYWRCYWxhbmNlckNvbnRyb2xsZXJBZGRPbiB9IGZyb20gXCIuLi9hd3MtbG9hZGJhbGFuY2VyLWNvbnRyb2xsZXJcIjtcbmltcG9ydCB7IEhlbG1BZGRPbiwgSGVsbUFkZE9uUHJvcHMsIEhlbG1BZGRPblVzZXJQcm9wcyB9IGZyb20gJy4uL2hlbG0tYWRkb24nO1xuXG5pbXBvcnQgKiBhcyBjZGsgZnJvbSAnYXdzLWNkay1saWInO1xuaW1wb3J0ICogYXMgZWZzIGZyb20gJ2F3cy1jZGstbGliL2F3cy1lZnMnO1xuaW1wb3J0ICogYXMgZWMyIGZyb20gJ2F3cy1jZGstbGliL2F3cy1lYzInO1xuaW1wb3J0IHsgSUNlcnRpZmljYXRlIH0gZnJvbSAnYXdzLWNkay1saWIvYXdzLWNlcnRpZmljYXRlbWFuYWdlcic7XG5cbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgRWJzQ3NpRHJpdmVyQWRkT24gfSBmcm9tIFwiLi4vZWJzLWNzaS1kcml2ZXJcIjtcbmltcG9ydCB7IEVmc0NzaURyaXZlckFkZE9uIH0gZnJvbSBcIi4uL2Vmcy1jc2ktZHJpdmVyXCI7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBleHBvc2luZyB0aGUgSnVweXRlckh1YiBwcm94eVxuICovXG5leHBvcnQgZW51bSBKdXB5dGVySHViU2VydmljZVR5cGUge1xuICAgIC8qKlxuICAgICAqIEV4cG9zZSB0aGUgc2VydmljZSB1c2luZyBBV1MgQXBwbGljYXRpb24gTG9hZCBCYWxhbmNlciArIEluZ3Jlc3MgY29udHJvbGxlclxuICAgICAqL1xuICAgIEFMQixcblxuICAgIC8qKlxuICAgICAqIEV4cG9zZSB0aGUgc2VydmljZSB1c2luZyBBV1MgTmV0d29yayBMb2FkIEJhbGFuY2VyICsgTG9hZEJhbGFuY2VyIHNlcnZpY2VcbiAgICAgKi9cbiAgICBOTEIsXG4gICAgXG4gICAgLyoqXG4gICAgICogVXNlIENsdXN0ZXJJUCBzZXJ2aWNlIHR5cGUgYW5kIGFsbG93IGN1c3RvbWVycyB0byBwb3J0LWZvcndhcmQgZm9yIGxvY2FsaG9zdCBhY2Nlc3NcbiAgICAgKi9cbiAgICBDTFVTVEVSSVAsXG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgYWRkLW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEp1cHl0ZXJIdWJBZGRPblByb3BzIGV4dGVuZHMgSGVsbUFkZE9uVXNlclByb3BzIHtcblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb25zIG5lY2Vzc2FyeSB0byB1c2UgRUJTIGFzIFBlcnNpc3RlbnQgVm9sdW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN0b3JhZ2VDbGFzcyAtIHN0b3JhZ2UgY2xhc3MgZm9yIHRoZSB2b2x1bWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gY2FwYWNpdHkgLSBzdG9yYWdlIGNhcGFjaXR5IChpbiBNaSBvciBHaSlcbiAgICAgKi9cbiAgICBlYnNDb25maWc/OiB7XG4gICAgICAgIHN0b3JhZ2VDbGFzczogc3RyaW5nLFxuICAgICAgICBjYXBhY2l0eTogc3RyaW5nLFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gbmVjZXNzYXJ5IHRvIHVzZSBFRlMgYXMgUGVyc2lzdGVudCBWb2x1bWVcbiAgICAgKiBAcHJvcGVydHkge2Nkay5SZW1vdmFsUG9saWN5fSByZW1vdmFsUG9saWN5IC0gUmVtb3ZhbCBQb2xpY3kgZm9yIEVGUyAoREVTVFJPWSwgUkVUQUlOIG9yIFNOQVBTSE9UKVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwdmNOYW1lIC0gTmFtZSBvZiB0aGUgVm9sdW1lIHRvIGJlIHVzZWQgZm9yIFBWIGFuZCBQVkNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gY2FwYWNpdHkgLSBTdG9yYWdlIENhcGFjaXR5IChpbiBNaSBvciBHaSlcbiAgICAgKi9cbiAgICBlZnNDb25maWc/OiB7XG4gICAgICAgIHJlbW92YWxQb2xpY3k6IGNkay5SZW1vdmFsUG9saWN5LFxuICAgICAgICBwdmNOYW1lOiBzdHJpbmcsXG4gICAgICAgIGNhcGFjaXR5OiBzdHJpbmcsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBzZXR0aW5ncyBmb3IgT3BlbklEIENvbm5lY3QgYXV0aGVudGljYXRpb24gcHJvdG9jb2xcbiAgICAgKi9cbiAgICBvaWRjQ29uZmlnPzoge1xuICAgICAgICBjYWxsYmFja1VybDogc3RyaW5nLFxuICAgICAgICBhdXRoVXJsOiBzdHJpbmcsXG4gICAgICAgIHRva2VuVXJsOiBzdHJpbmcsXG4gICAgICAgIHVzZXJEYXRhVXJsOiBzdHJpbmcsXG4gICAgICAgIGNsaWVudElkOiBzdHJpbmcsXG4gICAgICAgIGNsaWVudFNlY3JldDogc3RyaW5nLFxuICAgICAgICBzY29wZT86IHN0cmluZ1tdLFxuICAgICAgICB1c2VybmFtZUtleT86IHN0cmluZyxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIHRvIHNldCBob3cgdGhlIGh1YiBzZXJ2aWNlIHdpbGwgYmUgZXhwb3NlZFxuICAgICAqIFNlZSBlbnVtIGp1cHl0ZXJIdWJTZXJ2aWNlIGZvciBjaG9pY2VzXG4gICAgICovXG4gICAgc2VydmljZVR5cGU6IEp1cHl0ZXJIdWJTZXJ2aWNlVHlwZSxcblxuICAgIC8qKlxuICAgICAqIEluZ3Jlc3MgaG9zdCAtIG9ubHkgaWYgSW5ncmVzcyBpcyBlbmFibGVkXG4gICAgICogSXQgaXMgYSBsaXN0IG9mIGF2YWlsYWJsZSBob3N0cyB0byBiZSByb3V0ZWQgdXBvbiByZXF1ZXN0XG4gICAgICovXG4gICAgaW5ncmVzc0hvc3RzPzogc3RyaW5nW10sXG5cbiAgICAvKipcbiAgICAgKiBJbmdyZXNzIGFubm90YXRpb25zIC0gb25seSBhcHBseSBpZiBJbmdyZXNzIGlzIGVuYWJsZWQsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3JcbiAgICAgKi9cbiAgICBpbmdyZXNzQW5ub3RhdGlvbnM/OiB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGVib29rIHN0YWNrIGFzIGRlZmluZWQgdXNpbmcgRG9ja2VyIFN0YWNrcyBmb3IgSnVweXRlciBoZXJlOlxuICAgICAqIGh0dHBzOi8vanVweXRlci1kb2NrZXItc3RhY2tzLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC91c2luZy9zZWxlY3RpbmcuaHRtbCNjb3JlLXN0YWNrc1xuICAgICAqL1xuICAgIG5vdGVib29rU3RhY2s/OiBzdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBjZXJ0aWZpY2F0ZSB7QGxpbmsgTmFtZWRSZXNvdXJjZVByb3ZpZGVyfSB0byBiZSB1c2VkIGZvciBjZXJ0aWZpY2F0ZSBsb29rIHVwLiBcbiAgICAgKiBAc2VlIHtAbGluayBJbXBvcnRDZXJ0aWZpY2F0ZVByb3ZpZGVyfSBhbmQge0BsaW5rIENyZWF0ZUNlcnRpZmljYXRlUHJvdmlkZXJ9IGZvciBleGFtcGxlcyBvZiBjZXJ0aWZpY2F0ZSBwcm92aWRlcnMuXG4gICAgICovXG4gICAgY2VydGlmaWNhdGVSZXNvdXJjZU5hbWU/OiBzdHJpbmcsXG59XG5cbmNvbnN0IEpVUFlURVJIVUIgPSAnanVweXRlcmh1Yic7XG5jb25zdCBSRUxFQVNFID0gJ2JsdWVwcmludHMtYWRkb24tanVweXRlcmh1Yic7XG5cbi8qKlxuICogRGVmYXVsdHMgb3B0aW9ucyBmb3IgdGhlIGFkZC1vblxuICovXG5jb25zdCBkZWZhdWx0UHJvcHM6IEhlbG1BZGRPblByb3BzID0ge1xuICAgIG5hbWU6IEpVUFlURVJIVUIsXG4gICAgbmFtZXNwYWNlOiBKVVBZVEVSSFVCLFxuICAgIHZlcnNpb246ICcyLjAuMCcsXG4gICAgY2hhcnQ6IEpVUFlURVJIVUIsXG4gICAgcmVsZWFzZTogUkVMRUFTRSxcbiAgICByZXBvc2l0b3J5OiAnaHR0cHM6Ly9odWIuanVweXRlci5vcmcvaGVsbS1jaGFydC8nLFxuICAgIHZhbHVlczoge31cbn07XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIEp1cHl0ZXJIdWIgYWRkLW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBKdXB5dGVySHViQWRkT24gZXh0ZW5kcyBIZWxtQWRkT24ge1xuXG4gICAgcmVhZG9ubHkgb3B0aW9uczogSnVweXRlckh1YkFkZE9uUHJvcHM7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcz86IEp1cHl0ZXJIdWJBZGRPblByb3BzKSB7XG4gICAgICAgIHN1cGVyKHsuLi5kZWZhdWx0UHJvcHMsIC4uLnByb3BzfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMucHJvcHMgYXMgSnVweXRlckh1YkFkZE9uUHJvcHM7XG4gICAgfVxuICAgIFxuICAgIGRlcGxveShjbHVzdGVySW5mbzogQ2x1c3RlckluZm8pOiBQcm9taXNlPENvbnN0cnVjdD4ge1xuICAgICAgICBjb25zdCBjbHVzdGVyID0gY2x1c3RlckluZm8uY2x1c3RlcjtcbiAgICAgICAgbGV0IHZhbHVlcyA9IHRoaXMub3B0aW9ucy52YWx1ZXMgPz8ge307XG5cbiAgICAgICAgLy8gVGhlIGFkZG9uIHJlcXVpcmVzIGEgcGVyc2lzdGVudCBzdG9yYWdlIG9wdGlvblxuICAgICAgICBhc3NlcnQodGhpcy5vcHRpb25zLmVic0NvbmZpZyB8fCB0aGlzLm9wdGlvbnMuZWZzQ29uZmlnLCBcIllvdSBuZWVkIHRvIHByb3ZpZGUgYSBwZXJzaXN0ZW50IHN0b3JhZ2Ugb3B0aW9uLlwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEJ1dCB5b3UgY2FuIG9ubHkgcHJvdmlkZSBvbmUgb3B0aW9uIGZvciBwZXJzaXN0ZW50IHN0b3JhZ2VcbiAgICAgICAgYXNzZXJ0KCEodGhpcy5vcHRpb25zLmVic0NvbmZpZyAmJiB0aGlzLm9wdGlvbnMuZWZzQ29uZmlnKSwgXCJZb3UgY2Fubm90IHByb3ZpZGUgbW9yZSB0aGFuIG9uZSBwZXJzaXN0ZW50IHN0b3JhZ2Ugb3B0aW9uLlwiKTtcblxuICAgICAgICAvLyBDcmVhdGUgTmFtZXNwYWNlXG4gICAgICAgIGNvbnN0IG5zID0gY3JlYXRlTmFtZXNwYWNlKHRoaXMub3B0aW9ucy5uYW1lc3BhY2UhLCBjbHVzdGVyLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZXIgRW52aXJvbm1lbnQgc2V0dXBcbiAgICAgICAgbGV0IGNtZDtcbiAgICAgICAgaWYgKHNlbXZlci5sdCh0aGlzLm9wdGlvbnMudmVyc2lvbiEsICcyLjAuMCcpKXtcbiAgICAgICAgICAgIGNtZCA9IFtcInN0YXJ0LXNpbmdsZXVzZXIuc2hcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbWQgPSBbXCJqdXB5dGVyaHViLXNpbmdsZXVzZXJcIixcIi0tYWxsb3ctcm9vdFwiXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3RlYm9vayA9IHRoaXMub3B0aW9ucy5ub3RlYm9va1N0YWNrIHx8ICdqdXB5dGVyL2Jhc2Utbm90ZWJvb2snO1xuICAgICAgICBzZXRQYXRoKHZhbHVlcywgXCJzaW5nbGV1c2VyXCIsIHtcbiAgICAgICAgICAgIFwiaW1hZ2VcIjp7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IGAke25vdGVib29rfWAsXG4gICAgICAgICAgICAgICAgXCJ0YWdcIjogXCJsYXRlc3RcIiBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImV4dHJhRW52XCI6IHsgXCJDSE9XTl9IT01FXCI6IFwieWVzXCIgfSxcbiAgICAgICAgICAgIFwidWlkXCI6IDAsXG4gICAgICAgICAgICBcImZzR2lkXCI6IDAsXG4gICAgICAgICAgICBcImNtZFwiOiBjbWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUGVyc2lzdGVudCBTdG9yYWdlIFNldHVwIGZvciBFQlNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lYnNDb25maWcpe1xuICAgICAgICAgICAgdGhpcy5hZGRFYnNTdG9yYWdlKGNsdXN0ZXJJbmZvLCB2YWx1ZXMsIHRoaXMub3B0aW9ucy5lYnNDb25maWcpO1xuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgLy8gUGVyc2lzdGVudCBTdG9yYWdlIFNldHVwIGZvciBFRlNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lZnNDb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRWZzU3RvcmFnZShjbHVzdGVySW5mbywgdmFsdWVzLCB0aGlzLm9wdGlvbnMuZWZzQ29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9wZW5JRCBDb25uZWN0IGF1dGhlbnRpY2F0aW9uIHNldHVwXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub2lkY0NvbmZpZyl7XG4gICAgICAgICAgICBzZXRQYXRoKHZhbHVlcywgXCJodWIuY29uZmlnXCIsIHtcbiAgICAgICAgICAgICAgICBcIkp1cHl0ZXJIdWJcIjogeyBcImF1dGhlbnRpY2F0b3JfY2xhc3NcIjogXCJnZW5lcmljLW9hdXRoXCIgfSwgXG4gICAgICAgICAgICAgICAgXCJHZW5lcmljT0F1dGhlbnRpY2F0b3JcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImNsaWVudF9pZFwiOiB0aGlzLm9wdGlvbnMub2lkY0NvbmZpZy5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJjbGllbnRfc2VjcmV0XCI6IHRoaXMub3B0aW9ucy5vaWRjQ29uZmlnLmNsaWVudFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgXCJvYXV0aF9jYWxsYmFja191cmxcIjogdGhpcy5vcHRpb25zLm9pZGNDb25maWcuY2FsbGJhY2tVcmwsXG4gICAgICAgICAgICAgICAgICAgIFwiYXV0aG9yaXplX3VybFwiOiB0aGlzLm9wdGlvbnMub2lkY0NvbmZpZy5hdXRoVXJsLFxuICAgICAgICAgICAgICAgICAgICBcInRva2VuX3VybFwiOiB0aGlzLm9wdGlvbnMub2lkY0NvbmZpZy50b2tlblVybCxcbiAgICAgICAgICAgICAgICAgICAgXCJ1c2VyZGF0YV91cmxcIjogdGhpcy5vcHRpb25zLm9pZGNDb25maWcudXNlckRhdGFVcmwsXG4gICAgICAgICAgICAgICAgICAgIFwic2NvcGVcIjogIHRoaXMub3B0aW9ucy5vaWRjQ29uZmlnLnNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBcInVzZXJuYW1lX2tleVwiOiAgdGhpcy5vcHRpb25zLm9pZGNDb25maWcudXNlcm5hbWVLZXksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm94eSBpbmZvcm1hdGlvbiAtIHNldCBlaXRoZXIgQUxCLCBOTEIgKGRlZmF1bHQpIG9yIENsdXN0ZXJJUCBzZXJ2aWNlIGJhc2VkIG9uIFxuICAgICAgICAvLyBwcm92aWRlZCBjb25maWd1cmF0aW9uXG4gICAgICAgIGNvbnN0IHNlcnZpY2VUeXBlID0gdGhpcy5vcHRpb25zLnNlcnZpY2VUeXBlO1xuICAgICAgICBjb25zdCBpbmdyZXNzSG9zdHMgPSB0aGlzLm9wdGlvbnMuaW5ncmVzc0hvc3RzIHx8IFtdO1xuICAgICAgICBjb25zdCBpbmdyZXNzQW5ub3RhdGlvbnMgPSB0aGlzLm9wdGlvbnMuaW5ncmVzc0Fubm90YXRpb25zO1xuICAgICAgICBjb25zdCBjZXJ0ID0gdGhpcy5vcHRpb25zLmNlcnRpZmljYXRlUmVzb3VyY2VOYW1lO1xuXG4gICAgICAgIGNvbnN0IGFsYkFkZE9uQ2hlY2sgPSBjbHVzdGVySW5mby5nZXRTY2hlZHVsZWRBZGRPbihBd3NMb2FkQmFsYW5jZXJDb250cm9sbGVyQWRkT24ubmFtZSk7XG4gICAgICAgIC8vIFVzZSBJbmdyZXNzIGFuZCBBV1MgQUxCXG4gICAgICAgIGlmIChzZXJ2aWNlVHlwZSA9PSBKdXB5dGVySHViU2VydmljZVR5cGUuQUxCKXtcbiAgICAgICAgICAgIGFzc2VydChhbGJBZGRPbkNoZWNrLCBgTWlzc2luZyBhIGRlcGVuZGVuY3k6ICR7QXdzTG9hZEJhbGFuY2VyQ29udHJvbGxlckFkZE9uLm5hbWV9LiBQbGVhc2UgYWRkIGl0IHRvIHlvdXIgbGlzdCBvZiBhZGRvbnMuYCk7IFxuICAgICAgICAgICAgY29uc3QgcHJlc2V0QW5ub3RhdGlvbnM6IGFueSA9IHtcbiAgICAgICAgICAgICAgICAnYWxiLmluZ3Jlc3Mua3ViZXJuZXRlcy5pby9zY2hlbWUnOiAnaW50ZXJuZXQtZmFjaW5nJyxcbiAgICAgICAgICAgICAgICAnYWxiLmluZ3Jlc3Mua3ViZXJuZXRlcy5pby90YXJnZXQtdHlwZSc6ICdpcCcsXG4gICAgICAgICAgICAgICAgJ2t1YmVybmV0ZXMuaW8vaW5ncmVzcy5jbGFzcyc6ICdhbGInLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjZXJ0KXtcbiAgICAgICAgICAgICAgICBwcmVzZXRBbm5vdGF0aW9uc1snYWxiLmluZ3Jlc3Mua3ViZXJuZXRlcy5pby9zc2wtcmVkaXJlY3QnXSA9ICc0NDMnO1xuICAgICAgICAgICAgICAgIHByZXNldEFubm90YXRpb25zWydhbGIuaW5ncmVzcy5rdWJlcm5ldGVzLmlvL2xpc3Rlbi1wb3J0cyddID0gJ1t7XCJIVFRQXCI6IDgwfSx7XCJIVFRQU1wiOjQ0M31dJztcbiAgICAgICAgICAgICAgICBjb25zdCBjZXJ0aWZpY2F0ZSA9IGNsdXN0ZXJJbmZvLmdldFJlc291cmNlPElDZXJ0aWZpY2F0ZT4oY2VydCk7XG4gICAgICAgICAgICAgICAgcHJlc2V0QW5ub3RhdGlvbnNbJ2FsYi5pbmdyZXNzLmt1YmVybmV0ZXMuaW8vY2VydGlmaWNhdGUtYXJuJ10gPSBjZXJ0aWZpY2F0ZT8uY2VydGlmaWNhdGVBcm47XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSB7IC4uLmluZ3Jlc3NBbm5vdGF0aW9ucywgLi4ucHJlc2V0QW5ub3RhdGlvbnN9O1xuICAgICAgICAgICAgc2V0UGF0aCh2YWx1ZXMsIFwiaW5ncmVzcy5hbm5vdGF0aW9uc1wiLCBhbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBzZXRQYXRoKHZhbHVlcywgXCJpbmdyZXNzLmhvc3RzXCIsIGluZ3Jlc3NIb3N0cyk7XG4gICAgICAgICAgICBzZXRQYXRoKHZhbHVlcywgXCJpbmdyZXNzLmVuYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBzZXRQYXRoKHZhbHVlcywgXCJwcm94eS5zZXJ2aWNlXCIsIHtcInR5cGVcIiA6IFwiQ2x1c3RlcklQXCJ9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydCghaW5ncmVzc0hvc3RzIHx8IGluZ3Jlc3NIb3N0cy5sZW5ndGggPT0gMCwgJ0luZ3Jlc3MgSG9zdHMgQ0FOTk9UIGJlIGFzc2lnbmVkIHdoZW4gaW5ncmVzcyBpcyBkaXNhYmxlZCcpO1xuICAgICAgICAgICAgYXNzZXJ0KCFpbmdyZXNzQW5ub3RhdGlvbnMsICdJbmdyZXNzIGFubm90YXRpb25zIENBTk5PVCBiZSBhc3NpZ25lZCB3aGVuIGluZ3Jlc3MgaXMgZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIGFzc2VydCghY2VydCwgJ0NlcnQgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGlmIGluZ3Jlc3MgaXMgZW5hYmxlZC4nKTtcbiAgICAgICAgICAgIC8vIElmIHdlIHNldCBTVkMsIHNldCB0aGUgcHJveHkgc2VydmljZSB0eXBlIHRvIENsdXN0ZXJJUCBhbmQgYWxsb3cgdXNlcnMgdG8gcG9ydC1mb3J3YXJkIHRvIGxvY2FsaG9zdFxuICAgICAgICAgICAgaWYgKHNlcnZpY2VUeXBlID09IEp1cHl0ZXJIdWJTZXJ2aWNlVHlwZS5DTFVTVEVSSVApe1xuICAgICAgICAgICAgICAgIHNldFBhdGgodmFsdWVzLCBcInByb3h5LnNlcnZpY2VcIiwge1widHlwZVwiOiBcIkNsdXN0ZXJJUFwifSk7XG4gICAgICAgICAgICAvLyBXZSB3aWxsIHVzZSBOTEIgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydChhbGJBZGRPbkNoZWNrLCBgTWlzc2luZyBhIGRlcGVuZGVuY3k6ICR7QXdzTG9hZEJhbGFuY2VyQ29udHJvbGxlckFkZE9uLm5hbWV9LiBQbGVhc2UgYWRkIGl0IHRvIHlvdXIgbGlzdCBvZiBhZGRvbnMuYCk7IFxuICAgICAgICAgICAgICAgIHNldFBhdGgodmFsdWVzLCBcInByb3h5LnNlcnZpY2VcIiwgeyBcbiAgICAgICAgICAgICAgICAgICAgXCJhbm5vdGF0aW9uc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInNlcnZpY2UuYmV0YS5rdWJlcm5ldGVzLmlvL2F3cy1sb2FkLWJhbGFuY2VyLXR5cGVcIjogXCJubGJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2VydmljZS5iZXRhLmt1YmVybmV0ZXMuaW8vYXdzLWxvYWQtYmFsYW5jZXItc2NoZW1lXCI6IFwiaW50ZXJuZXQtZmFjaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNlcnZpY2UuYmV0YS5rdWJlcm5ldGVzLmlvL2F3cy1sb2FkLWJhbGFuY2VyLW5sYi10YXJnZXQtdHlwZVwiOiBcImlwXCIsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBIZWxtIENoYXJ0XG4gICAgICAgIGNvbnN0IGp1cHl0ZXJIdWJDaGFydCA9IHRoaXMuYWRkSGVsbUNoYXJ0KGNsdXN0ZXJJbmZvLCB2YWx1ZXMsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gQWRkIGRlcGVuZGVuY3lcbiAgICAgICAganVweXRlckh1YkNoYXJ0Lm5vZGUuYWRkRGVwZW5kZW5jeShucyk7XG5cbiAgICAgICAgaWYoYWxiQWRkT25DaGVjaykge1xuICAgICAgICAgICAgYWxiQWRkT25DaGVjay50aGVuKGNvbnN0cnVjdCA9PiBqdXB5dGVySHViQ2hhcnQubm9kZS5hZGREZXBlbmRlbmN5KGNvbnN0cnVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoanVweXRlckh1YkNoYXJ0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgRUJTIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgICAqIEBwYXJhbSB7Q2x1c3RlckluZm99IGNsdXN0ZXJJbmZvIC0gQ2x1c3RlciBJbmZvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlcyAtIEhlbG0gQ2hhcnQgVmFsdWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVic0NvbmZpZyAtIEVCUyBDb25maWd1cmF0aW9ucyBzdXBwbGllZCBieSB1c2VyXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWRkRWJzU3RvcmFnZShjbHVzdGVySW5mbzogQ2x1c3RlckluZm8sIHZhbHVlczogYW55LCBlYnNDb25maWc6IGFueSl7XG4gICAgICAgIGNvbnN0IGRlcCA9IGNsdXN0ZXJJbmZvLmdldFNjaGVkdWxlZEFkZE9uKEVic0NzaURyaXZlckFkZE9uLm5hbWUpO1xuICAgICAgICBhc3NlcnQoZGVwLCBgTWlzc2luZyBhIGRlcGVuZGVuY3k6ICR7RWJzQ3NpRHJpdmVyQWRkT24ubmFtZX0uIFBsZWFzZSBhZGQgaXQgdG8geW91ciBsaXN0IG9mIGFkZG9ucy5gKTsgXG4gICAgICAgIC8vIENyZWF0ZSBwZXJzaXN0ZW50IHN0b3JhZ2Ugd2l0aCBFQlNcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNsYXNzID0gZWJzQ29uZmlnLnN0b3JhZ2VDbGFzcztcbiAgICAgICAgY29uc3QgZWJzQ2FwYWNpdHkgPSBlYnNDb25maWcuY2FwYWNpdHk7XG4gICAgICAgIHNldFBhdGgodmFsdWVzLCBcInNpbmdsZXVzZXIuc3RvcmFnZVwiLCB7XG4gICAgICAgICAgICBcImR5bmFtaWNcIjogeyBcInN0b3JhZ2VDbGFzc1wiOiBzdG9yYWdlQ2xhc3MgfSxcbiAgICAgICAgICAgIFwiY2FwYWNpdHlcIjogZWJzQ2FwYWNpdHlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgRUZTIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgICAqIEBwYXJhbSB7Q2x1c3RlckluZm99IGNsdXN0ZXJJbmZvIC0gQ2x1c3RlciBJbmZvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlcyAtIEhlbG0gQ2hhcnQgVmFsdWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVmc0NvbmZpZyAtIEVGUyBDb25maWd1cmF0aW9ucyBzdXBwbGllZCBieSB1c2VyXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWRkRWZzU3RvcmFnZShjbHVzdGVySW5mbzogQ2x1c3RlckluZm8sIHZhbHVlczogYW55LCBlZnNDb25maWc6IGFueSl7XG4gICAgICAgIGNvbnN0IGRlcCA9IGNsdXN0ZXJJbmZvLmdldFNjaGVkdWxlZEFkZE9uKEVmc0NzaURyaXZlckFkZE9uLm5hbWUpO1xuICAgICAgICBhc3NlcnQoZGVwLCBgTWlzc2luZyBhIGRlcGVuZGVuY3k6ICR7RWZzQ3NpRHJpdmVyQWRkT24ubmFtZX0uIFBsZWFzZSBhZGQgaXQgdG8geW91ciBsaXN0IG9mIGFkZG9ucy5gKTsgXG5cbiAgICAgICAgY29uc3QgcHZjTmFtZSA9IGVmc0NvbmZpZy5wdmNOYW1lO1xuICAgICAgICBjb25zdCByZW1vdmFsUG9saWN5ID0gZWZzQ29uZmlnLnJlbW92YWxQb2xpY3k7XG4gICAgICAgIGNvbnN0IGVmc0NhcGFjaXR5ID0gZWZzQ29uZmlnLmNhcGFjaXR5O1xuXG4gICAgICAgIHRoaXMuc2V0dXBFRlMoY2x1c3RlckluZm8sIHRoaXMub3B0aW9ucy5uYW1lc3BhY2UhLCBwdmNOYW1lLCBlZnNDYXBhY2l0eSwgcmVtb3ZhbFBvbGljeSk7XG4gICAgICAgIHNldFBhdGgodmFsdWVzLCBcInNpbmdsZXVzZXIuc3RvcmFnZVwiLCB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdGF0aWNcIixcbiAgICAgICAgICAgIFwic3RhdGljXCI6IHtcbiAgICAgICAgICAgICAgICBcInB2Y05hbWVcIjogYCR7cHZjTmFtZX1gLFxuICAgICAgICAgICAgICAgIFwic3ViUGF0aFwiOiBcImhvbWUve3VzZXJuYW1lfVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIHVzZSBFRlMgYXMgcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICogaW5jbHVkaW5nIG5lY2Vzc2FyeSBzZWN1cml0eSBncm91cCB3aXRoIGluZ3Jlc3MgcnVsZSxcbiAgICAgKiBFRlMgRmlsZSBTeXN0ZW0sIEt1YmVybmV0ZXMgUFYgYW5kIFBWQ1xuICAgICAqIEBwYXJhbSB7Q2x1c3RlckluZm99IGNsdXN0ZXJJbmZvIC0gQ2x1c3RlciBJbmZvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSAtIE5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdmNOYW1lIC0gTmFtZSBvZiB0aGUgUFYgYW5kIFBWQ1xuICAgICAqIEBwYXJhbSB7UmVtb3ZhbFBvbGljeX1yZW1vdmFsUG9saWN5IC0gUmVtb3ZhbCBQb2xpY3kgZm9yIEVGUyBGaWxlIFN5c3RlbSAoUkVUQUlOLCBERVNUUk9ZIG9yIFNOQVBTSE9UKVxuICAgICAqIEByZXR1cm5zXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgc2V0dXBFRlMoY2x1c3RlckluZm86IENsdXN0ZXJJbmZvLCBuYW1lc3BhY2U6IHN0cmluZywgcHZjTmFtZTogc3RyaW5nLCBjYXBhY2l0eTogc3RyaW5nLCByZW1vdmFsUG9saWN5OiBjZGsuUmVtb3ZhbFBvbGljeSl7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBjbHVzdGVySW5mby5jbHVzdGVyO1xuICAgICAgICBjb25zdCBjbHVzdGVyVnBjQ2lkciA9IGNsdXN0ZXJJbmZvLmNsdXN0ZXIudnBjLnZwY0NpZHJCbG9jaztcblxuICAgICAgICAvLyBTZWN1cml0eSBHcm91cCByZXF1aXJlZCBmb3IgYWNjZXNzIHRvIHRoZSBGaWxlIFN5c3RlbVxuICAgICAgICAvLyBXaXRoIHRoZSByaWdodCBpbmdyZXNzIHJ1bGVcbiAgICAgICAgY29uc3QganVweXRlckh1YlNHID0gbmV3IGVjMi5TZWN1cml0eUdyb3VwKFxuICAgICAgICAgICAgY2x1c3Rlci5zdGFjaywgJ015RWZzU2VjdXJpdHlHcm91cCcsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdnBjOiBjbHVzdGVySW5mby5jbHVzdGVyLnZwYyxcbiAgICAgICAgICAgICAgICBzZWN1cml0eUdyb3VwTmFtZTogXCJFa3NCbHVlcHJpbnRzSkh1YkVGU1NHXCIsXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGp1cHl0ZXJIdWJTRy5hZGRJbmdyZXNzUnVsZShcbiAgICAgICAgICAgIGVjMi5QZWVyLmlwdjQoY2x1c3RlclZwY0NpZHIpLFxuICAgICAgICAgICAgbmV3IGVjMi5Qb3J0KHtcbiAgICAgICAgICAgICAgICBwcm90b2NvbDogZWMyLlByb3RvY29sLlRDUCxcbiAgICAgICAgICAgICAgICBzdHJpbmdSZXByZXNlbnRhdGlvbjogXCJFRlNjb25uZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgdG9Qb3J0OiAyMDQ5LFxuICAgICAgICAgICAgICAgIGZyb21Qb3J0OiAyMDQ5LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBFRlMgRmlsZSBTeXN0ZW1cbiAgICAgICAgY29uc3QganVweXRlckh1YkZpbGVTeXN0ZW0gPSBuZXcgZWZzLkZpbGVTeXN0ZW0oXG4gICAgICAgICAgICBjbHVzdGVyLnN0YWNrLCAnTXlFZnNGaWxlU3lzdGVtJywgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdnBjOiBjbHVzdGVySW5mby5jbHVzdGVyLnZwYyxcbiAgICAgICAgICAgICAgICBzZWN1cml0eUdyb3VwOiBqdXB5dGVySHViU0csXG4gICAgICAgICAgICAgICAgcmVtb3ZhbFBvbGljeTogcmVtb3ZhbFBvbGljeSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZWZzSWQgPSBqdXB5dGVySHViRmlsZVN5c3RlbS5maWxlU3lzdGVtSWQ7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgU3RvcmFnZUNsYXNzXG4gICAgICAgIGNvbnN0IGVmc1NDID0gY2x1c3Rlci5hZGRNYW5pZmVzdCgnZWZzLXN0b3JhZ2UtY2xhc3MnLCB7XG4gICAgICAgICAgICBhcGlWZXJzaW9uOiAnc3RvcmFnZS5rOHMuaW8vdjEnLFxuICAgICAgICAgICAga2luZDogJ1N0b3JhZ2VDbGFzcycsXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdlZnMtc2MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3Zpc2lvbmVyOiAnZWZzLmNzaS5hd3MuY29tJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2V0dXAgUGVyc2lzdGVudFZvbHVtZSBhbmQgUGVyc2lzdGVudFZvbHVtZUNsYWltXG4gICAgICAgIGNvbnN0IGVmc1BWID0gY2x1c3Rlci5hZGRNYW5pZmVzdCgnZWZzLXB2Jywge1xuICAgICAgICAgICAgYXBpVmVyc2lvbjogJ3YxJyxcbiAgICAgICAgICAgIGtpbmQ6ICdQZXJzaXN0ZW50Vm9sdW1lJyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7IFxuICAgICAgICAgICAgICAgIG5hbWU6IGAke3B2Y05hbWV9YCxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNwZWM6IHtcbiAgICAgICAgICAgICAgICBjYXBhY2l0eTogeyBzdG9yYWdlOiBgJHtjYXBhY2l0eX1gIH0sXG4gICAgICAgICAgICAgICAgdm9sdW1lTW9kZTogJ0ZpbGVzeXN0ZW0nLFxuICAgICAgICAgICAgICAgIGFjY2Vzc01vZGVzOiBbICdSZWFkV3JpdGVNYW55JyBdLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2VDbGFzc05hbWU6ICdlZnMtc2MnLFxuICAgICAgICAgICAgICAgIGNzaToge1xuICAgICAgICAgICAgICAgICAgICBkcml2ZXI6ICdlZnMuY3NpLmF3cy5jb20nLFxuICAgICAgICAgICAgICAgICAgICB2b2x1bWVIYW5kbGU6IGAke2Vmc0lkfWAsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGVmc1BWLm5vZGUuYWRkRGVwZW5kZW5jeShlZnNTQyk7XG4gICAgICAgIGVmc1BWLm5vZGUuYWRkRGVwZW5kZW5jeShqdXB5dGVySHViRmlsZVN5c3RlbSk7XG5cbiAgICAgICAgY29uc3QgZWZzUFZDID0gY2x1c3Rlci5hZGRNYW5pZmVzdCgnZWZzLXB2YycsIHtcbiAgICAgICAgICAgIGFwaVZlcnNpb246ICd2MScsXG4gICAgICAgICAgICBraW5kOiAnUGVyc2lzdGVudFZvbHVtZUNsYWltJyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7IFxuICAgICAgICAgICAgICAgIG5hbWU6IGAke3B2Y05hbWV9YCxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNwZWM6IHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlQ2xhc3NOYW1lOiAnZWZzLXNjJyxcbiAgICAgICAgICAgICAgICBhY2Nlc3NNb2RlczogWyAnUmVhZFdyaXRlTWFueScgXSxcbiAgICAgICAgICAgICAgICByZXNvdXJjZXM6IHsgcmVxdWVzdHM6IHsgc3RvcmFnZTogYCR7Y2FwYWNpdHl9YCB9IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZWZzUFZDLm5vZGUuYWRkRGVwZW5kZW5jeShlZnNQVik7XG4gICAgfVxufVxuXG4iXX0=