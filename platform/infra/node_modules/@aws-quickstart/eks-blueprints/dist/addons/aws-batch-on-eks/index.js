"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsBatchAddOn = void 0;
const assert = require("assert");
const aws_cdk_lib_1 = require("aws-cdk-lib");
const aws_eks_1 = require("aws-cdk-lib/aws-eks");
const aws_iam_1 = require("aws-cdk-lib/aws-iam");
const BATCH = 'aws-batch';
class AwsBatchAddOn {
    deploy(clusterInfo) {
        assert(clusterInfo.cluster instanceof aws_eks_1.Cluster, "AwsBatchAddOn cannot be used with imported clusters");
        const cluster = clusterInfo.cluster;
        const roleNameforBatch = 'AWSServiceRoleForBatch';
        const slrCheck = aws_iam_1.Role.fromRoleName(cluster.stack, 'BatchServiceLinkedRole', roleNameforBatch);
        // Create the service role used by AWS Batch on EKS if one doesn't exist
        if (slrCheck.roleName != roleNameforBatch) {
            new aws_iam_1.CfnServiceLinkedRole(cluster.stack, 'BatchServiceRole', {
                awsServiceName: 'batch.amazonaws.com',
            });
        }
        //Init the service role as IRole because `addRoleMapping` method does not
        //support the CfnServiceLinkedRole type
        const batchEksServiceRole = aws_iam_1.Role.fromRoleArn(cluster.stack, 'ServiceRoleForBatch', `arn:aws:iam::${aws_cdk_lib_1.Stack.of(cluster.stack).account}:role/AWSServiceRoleForBatch`);
        //Add the service role to the AwsAuth
        cluster.awsAuth.addRoleMapping(batchEksServiceRole, {
            username: BATCH,
            groups: ['']
        });
        return Promise.resolve(batchEksServiceRole);
    }
}
exports.AwsBatchAddOn = AwsBatchAddOn;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRkb25zL2F3cy1iYXRjaC1vbi1la3MvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWtDO0FBRWxDLDZDQUFvQztBQUNwQyxpREFBOEM7QUFDOUMsaURBQXdFO0FBR3hFLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQztBQUUxQixNQUFhLGFBQWE7SUFDeEIsTUFBTSxDQUFDLFdBQXdCO1FBQzdCLE1BQU0sQ0FBQyxXQUFXLENBQUMsT0FBTyxZQUFZLGlCQUFPLEVBQUUscURBQXFELENBQUMsQ0FBQztRQUN0RyxNQUFNLE9BQU8sR0FBWSxXQUFXLENBQUMsT0FBTyxDQUFDO1FBQzdDLE1BQU0sZ0JBQWdCLEdBQUcsd0JBQXdCLENBQUM7UUFDbEQsTUFBTSxRQUFRLEdBQUcsY0FBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLHdCQUF3QixFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFFOUYsd0VBQXdFO1FBQ3hFLElBQUksUUFBUSxDQUFDLFFBQVEsSUFBSSxnQkFBZ0IsRUFBQztZQUN4QyxJQUFJLDhCQUFvQixDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsa0JBQWtCLEVBQUU7Z0JBQzFELGNBQWMsRUFBRSxxQkFBcUI7YUFDdEMsQ0FBQyxDQUFDO1NBQ0o7UUFFRCx5RUFBeUU7UUFDekUsdUNBQXVDO1FBQ3ZDLE1BQU0sbUJBQW1CLEdBQVUsY0FBSSxDQUFDLFdBQVcsQ0FDakQsT0FBTyxDQUFDLEtBQUssRUFDYixxQkFBcUIsRUFDckIsZ0JBQWdCLG1CQUFLLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLDhCQUE4QixDQUM5RSxDQUFDO1FBRUYscUNBQXFDO1FBQ3JDLE9BQU8sQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUM1QixtQkFBbUIsRUFDbkI7WUFDRSxRQUFRLEVBQUUsS0FBSztZQUNmLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQztTQUNiLENBQ0YsQ0FBQztRQUVGLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBRTlDLENBQUM7Q0FDRjtBQWxDRCxzQ0FrQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmltcG9ydCB7IENsdXN0ZXJBZGRPbiwgQ2x1c3RlckluZm8gfSBmcm9tIFwiLi4vLi4vc3BpXCI7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gXCJhd3MtY2RrLWxpYlwiO1xuaW1wb3J0IHsgQ2x1c3RlciB9IGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtZWtzXCI7XG5pbXBvcnQgeyBDZm5TZXJ2aWNlTGlua2VkUm9sZSwgSVJvbGUsIFJvbGUgfSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWlhbVwiO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcblxuY29uc3QgQkFUQ0ggPSAnYXdzLWJhdGNoJztcblxuZXhwb3J0IGNsYXNzIEF3c0JhdGNoQWRkT24gaW1wbGVtZW50cyBDbHVzdGVyQWRkT24ge1xuICBkZXBsb3koY2x1c3RlckluZm86IENsdXN0ZXJJbmZvKTogUHJvbWlzZTxDb25zdHJ1Y3Q+IHtcbiAgICBhc3NlcnQoY2x1c3RlckluZm8uY2x1c3RlciBpbnN0YW5jZW9mIENsdXN0ZXIsIFwiQXdzQmF0Y2hBZGRPbiBjYW5ub3QgYmUgdXNlZCB3aXRoIGltcG9ydGVkIGNsdXN0ZXJzXCIpO1xuICAgIGNvbnN0IGNsdXN0ZXI6IENsdXN0ZXIgPSBjbHVzdGVySW5mby5jbHVzdGVyO1xuICAgIGNvbnN0IHJvbGVOYW1lZm9yQmF0Y2ggPSAnQVdTU2VydmljZVJvbGVGb3JCYXRjaCc7XG4gICAgY29uc3Qgc2xyQ2hlY2sgPSBSb2xlLmZyb21Sb2xlTmFtZShjbHVzdGVyLnN0YWNrLCAnQmF0Y2hTZXJ2aWNlTGlua2VkUm9sZScsIHJvbGVOYW1lZm9yQmF0Y2gpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBzZXJ2aWNlIHJvbGUgdXNlZCBieSBBV1MgQmF0Y2ggb24gRUtTIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKHNsckNoZWNrLnJvbGVOYW1lICE9IHJvbGVOYW1lZm9yQmF0Y2gpe1xuICAgICAgbmV3IENmblNlcnZpY2VMaW5rZWRSb2xlKGNsdXN0ZXIuc3RhY2ssICdCYXRjaFNlcnZpY2VSb2xlJywge1xuICAgICAgICBhd3NTZXJ2aWNlTmFtZTogJ2JhdGNoLmFtYXpvbmF3cy5jb20nLFxuICAgICAgfSk7XG4gICAgfSAgICBcblxuICAgIC8vSW5pdCB0aGUgc2VydmljZSByb2xlIGFzIElSb2xlIGJlY2F1c2UgYGFkZFJvbGVNYXBwaW5nYCBtZXRob2QgZG9lcyBub3RcbiAgICAvL3N1cHBvcnQgdGhlIENmblNlcnZpY2VMaW5rZWRSb2xlIHR5cGVcbiAgICBjb25zdCBiYXRjaEVrc1NlcnZpY2VSb2xlOiBJUm9sZSA9IFJvbGUuZnJvbVJvbGVBcm4oXG4gICAgICBjbHVzdGVyLnN0YWNrLFxuICAgICAgJ1NlcnZpY2VSb2xlRm9yQmF0Y2gnLFxuICAgICAgYGFybjphd3M6aWFtOjoke1N0YWNrLm9mKGNsdXN0ZXIuc3RhY2spLmFjY291bnR9OnJvbGUvQVdTU2VydmljZVJvbGVGb3JCYXRjaGAsXG4gICAgKTtcbiAgICBcbiAgICAvL0FkZCB0aGUgc2VydmljZSByb2xlIHRvIHRoZSBBd3NBdXRoXG4gICAgY2x1c3Rlci5hd3NBdXRoLmFkZFJvbGVNYXBwaW5nKFxuICAgICAgYmF0Y2hFa3NTZXJ2aWNlUm9sZSxcbiAgICAgIHtcbiAgICAgICAgdXNlcm5hbWU6IEJBVENILFxuICAgICAgICBncm91cHM6IFsnJ11cbiAgICAgIH1cbiAgICApO1xuICBcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJhdGNoRWtzU2VydmljZVJvbGUpO1xuXG4gIH1cbn0iXX0=